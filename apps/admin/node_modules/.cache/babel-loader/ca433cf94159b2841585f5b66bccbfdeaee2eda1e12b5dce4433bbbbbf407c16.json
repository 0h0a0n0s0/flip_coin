{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { eqNaN, isArray, isNumber } from 'zrender/lib/core/util.js';\nimport { WH, XY } from '../../util/graphic.js';\nimport { mathMax, mathMin } from '../../util/number.js';\nexport var MatrixCellLayoutInfoType = {\n  level: 1,\n  leaf: 2,\n  nonLeaf: 3\n};\n/**\n * @public Public to users in `chart.convertFromPixel`.\n */\nexport var MatrixClampOption = {\n  // No clamp, be falsy, equals to null/undefined. It means if the input part is\n  // null/undefined/NaN/outOfBoundary, the result part is NaN, rather than clamp to\n  // the boundary of the matrix.\n  none: 0,\n  // Clamp, where null/undefined/NaN/outOfBoundary can be used to cover the entire row/column.\n  all: 1,\n  body: 2,\n  corner: 3\n};\n/**\n * For the x direction,\n *  - find dimension cell from `xMatrixDim`,\n *      - If `xDimCell` or `yDimCell` is not a leaf, return the non-leaf cell itself.\n *  - otherwise find level from `yMatrixDim`.\n *  - otherwise return `NullUndefined`.\n *\n * For the y direction, it's the opposite.\n */\nexport function coordDataToAllCellLevelLayout(coordValue, dims, thisDimIdx // 0 | 1\n) {\n  // Find in body.\n  var result = dims[XY[thisDimIdx]].getCell(coordValue);\n  // Find in corner or dimension area.\n  if (!result && isNumber(coordValue) && coordValue < 0) {\n    result = dims[XY[1 - thisDimIdx]].getUnitLayoutInfo(thisDimIdx, Math.round(coordValue));\n  }\n  return result;\n}\nexport function resetXYLocatorRange(out) {\n  var rg = out || [];\n  rg[0] = rg[0] || [];\n  rg[1] = rg[1] || [];\n  rg[0][0] = rg[0][1] = rg[1][0] = rg[1][1] = NaN;\n  return rg;\n}\n/**\n * If illegal or out of boundary, set NaN to `locOut`. See `isXYLocatorRangeInvalidOnDim`.\n * x dimension and y dimension are calculated separately.\n */\nexport function parseCoordRangeOption(locOut,\n// If illegal input or can not find any target, save reason to it.\n// Do nothing if `NullUndefined`.\nreasonOut, data, dims, clamp) {\n  // x and y are supported to be handled separately - if one dimension is invalid\n  // (may be users do not need that), the other one should also be calculated.\n  parseCoordRangeOptionOnOneDim(locOut[0], reasonOut, clamp, data, dims, 0);\n  parseCoordRangeOptionOnOneDim(locOut[1], reasonOut, clamp, data, dims, 1);\n}\nfunction parseCoordRangeOptionOnOneDim(locDimOut, reasonOut, clamp, data, dims, dimIdx) {\n  locDimOut[0] = Infinity;\n  locDimOut[1] = -Infinity;\n  var dataOnDim = data[dimIdx];\n  var coordValArr = isArray(dataOnDim) ? dataOnDim : [dataOnDim];\n  var len = coordValArr.length;\n  var hasClamp = !!clamp;\n  if (len >= 1) {\n    parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, 0);\n    if (len > 1) {\n      // Users may intuitively input the coords like `[[x1, x2, x3], ...]`;\n      // consider the range as `[x1, x3]` in this case.\n      parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, len - 1);\n    }\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      if (reasonOut) {\n        reasonOut.push('Should be like [[\"x1\", \"x2\"], [\"y1\", \"y2\"]], or [\"x1\", \"y1\"], rather than empty.');\n      }\n    }\n    locDimOut[0] = locDimOut[1] = NaN;\n  }\n  if (hasClamp) {\n    // null/undefined/NaN or illegal data represents the entire row/column;\n    // Cover the entire locator regardless of body or corner, and confine it later.\n    var locLowerBound = -dims[XY[1 - dimIdx]].getLocatorCount(dimIdx);\n    var locUpperBound = dims[XY[dimIdx]].getLocatorCount(dimIdx) - 1;\n    if (clamp === MatrixClampOption.body) {\n      locLowerBound = mathMax(0, locLowerBound);\n    } else if (clamp === MatrixClampOption.corner) {\n      locUpperBound = mathMin(-1, locUpperBound);\n    }\n    if (locUpperBound < locLowerBound) {\n      // Also considered that both x and y has no cell.\n      locLowerBound = locUpperBound = NaN;\n    }\n    if (eqNaN(locDimOut[0])) {\n      locDimOut[0] = locLowerBound;\n    }\n    if (eqNaN(locDimOut[1])) {\n      locDimOut[1] = locUpperBound;\n    }\n    locDimOut[0] = mathMax(mathMin(locDimOut[0], locUpperBound), locLowerBound);\n    locDimOut[1] = mathMax(mathMin(locDimOut[1], locUpperBound), locLowerBound);\n  }\n}\n// The return val must be finite or NaN.\nfunction parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, partIdx) {\n  var layout = coordDataToAllCellLevelLayout(coordValArr[partIdx], dims, dimIdx);\n  if (!layout) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!hasClamp && reasonOut) {\n        reasonOut.push(\"Can not find cell by coord[\" + dimIdx + \"][\" + partIdx + \"].\");\n      }\n    }\n    locDimOut[0] = locDimOut[1] = NaN;\n    return;\n  }\n  var locatorA = layout.id[XY[dimIdx]];\n  var locatorB = locatorA;\n  var dimCell = cellLayoutInfoToDimCell(layout);\n  if (dimCell) {\n    // Handle non-leaf\n    locatorB += dimCell.span[XY[dimIdx]] - 1;\n  }\n  locDimOut[0] = mathMin(locDimOut[0], locatorA, locatorB);\n  locDimOut[1] = mathMax(locDimOut[1], locatorA, locatorB);\n}\n/**\n * @param locatorRange Must be the return of `parseCoordRangeOption`,\n *  where if not NaN, it must be a valid locator.\n */\nexport function isXYLocatorRangeInvalidOnDim(locatorRange, dimIdx) {\n  return eqNaN(locatorRange[dimIdx][0]) || eqNaN(locatorRange[dimIdx][1]);\n}\n// `locatorRange` will be expanded (modified) if an intersection is encountered.\nexport function resolveXYLocatorRangeByCellMerge(inOutLocatorRange,\n// Item indices coorespond to mergeDefList (len: mergeDefListTravelLen).\n// Indicating whether each item has be merged into the `locatorRange`\noutMergedMarkList, mergeDefList, mergeDefListTravelLen) {\n  outMergedMarkList = outMergedMarkList || _tmpOutMergedMarkList;\n  for (var idx = 0; idx < mergeDefListTravelLen; idx++) {\n    outMergedMarkList[idx] = false;\n  }\n  // In most case, cell merging definition list length is smaller than the range extent,\n  // therefore, to detection intersection, travelling cell merging definition list is probably\n  // performant than traveling the four edges of the rect formed by the locator range.\n  while (true) {\n    var expanded = false;\n    for (var idx = 0; idx < mergeDefListTravelLen; idx++) {\n      var mergeDef = mergeDefList[idx];\n      if (!outMergedMarkList[idx] && mergeDef.cellMergeOwner && expandXYLocatorRangeIfIntersect(inOutLocatorRange, mergeDef.locatorRange)) {\n        outMergedMarkList[idx] = true;\n        expanded = true;\n      }\n    }\n    if (!expanded) {\n      break;\n    }\n  }\n}\nvar _tmpOutMergedMarkList = [];\n// Return whether intersect.\n// `thisLocRange` will be expanded (modified) if an intersection is encountered.\nfunction expandXYLocatorRangeIfIntersect(thisLocRange, otherLocRange) {\n  if (!locatorRangeIntersectOneDim(thisLocRange[0], otherLocRange[0]) || !locatorRangeIntersectOneDim(thisLocRange[1], otherLocRange[1])) {\n    return false;\n  }\n  thisLocRange[0][0] = mathMin(thisLocRange[0][0], otherLocRange[0][0]);\n  thisLocRange[0][1] = mathMax(thisLocRange[0][1], otherLocRange[0][1]);\n  thisLocRange[1][0] = mathMin(thisLocRange[1][0], otherLocRange[1][0]);\n  thisLocRange[1][1] = mathMax(thisLocRange[1][1], otherLocRange[1][1]);\n  return true;\n}\n// Notice: If containing NaN, not intersect.\nfunction locatorRangeIntersectOneDim(locRange1OneDim, locRange2OneDim) {\n  return locRange1OneDim[1] >= locRange2OneDim[0] && locRange1OneDim[0] <= locRange2OneDim[1];\n}\nexport function fillIdSpanFromLocatorRange(owner, locatorRange) {\n  owner.id.set(locatorRange[0][0], locatorRange[1][0]);\n  owner.span.set(locatorRange[0][1] - owner.id.x + 1, locatorRange[1][1] - owner.id.y + 1);\n}\nexport function cloneXYLocatorRange(target, source) {\n  target[0][0] = source[0][0];\n  target[0][1] = source[0][1];\n  target[1][0] = source[1][0];\n  target[1][1] = source[1][1];\n}\n/**\n * If illegal, the corresponding x/y/width/height is set to `NaN`.\n * `x/width` or `y/height` is supported to be calculated separately,\n * i.e., one side are NaN, the other side are normal.\n * @param oneDimOut only write to `x/width` or `y/height`, depending on `dimIdx`.\n */\nexport function xyLocatorRangeToRectOneDim(oneDimOut, locRange, dims, dimIdx) {\n  var layoutMin = coordDataToAllCellLevelLayout(locRange[dimIdx][0], dims, dimIdx);\n  var layoutMax = coordDataToAllCellLevelLayout(locRange[dimIdx][1], dims, dimIdx);\n  oneDimOut[XY[dimIdx]] = oneDimOut[WH[dimIdx]] = NaN;\n  if (layoutMin && layoutMax) {\n    oneDimOut[XY[dimIdx]] = layoutMin.xy;\n    oneDimOut[WH[dimIdx]] = layoutMax.xy + layoutMax.wh - layoutMin.xy;\n  }\n}\n// No need currently, since `span` is not allowed to be defined directly by users.\n// /**\n//  * If either span x or y is valid and > 1, return parsed span, otherwise return `NullUndefined`.\n//  */\n// export function parseSpanOption(\n//     spanOptionHost: MatrixCellSpanOptionHost,\n//     dimCellPair: MatrixCellLayoutInfo[]\n// ): Point | NullUndefined {\n//     const spanX = parseSpanOnDim(spanOptionHost.spanX, dimCellPair[0], 0);\n//     const spanY = parseSpanOnDim(spanOptionHost.spanY, dimCellPair[1], 1);\n//     if (!eqNaN(spanX) || !eqNaN(spanY)) {\n//         return new Point(spanX || 1, spanY || 1);\n//     }\n//     function parseSpanOnDim(spanOption: unknown, dimCell: MatrixCellLayoutInfo, dimIdx: number): number {\n//         if (!isNumber(spanOption)) {\n//             return NaN;\n//         }\n//         // Ensure positive integer (not NaN) to avoid dead loop.\n//         const span = mathMax(1, Math.round(spanOption || 1)) || 1;\n//         // Clamp, and consider may also be specified as `Infinity` to span the entire col/row.\n//         return mathMin(span, mathMax(1, dimCell.dim.getLocatorCount(dimIdx) - dimCell.id[XY[dimIdx]]));\n//     }\n// }\n/**\n * @usage To get/set on dimension, use:\n *  `xyVal[XY[dim]] = val;` // set on this dimension.\n *  `xyVal[XY[1 - dim]] = val;` // set on the perpendicular dimension.\n */\nexport function setDimXYValue(out, dimIdx,\n// 0 | 1\nvalueOnThisDim, valueOnOtherDim) {\n  out[XY[dimIdx]] = valueOnThisDim;\n  out[XY[1 - dimIdx]] = valueOnOtherDim;\n  return out;\n}\n/**\n * Return NullUndefined if not dimension cell.\n */\nfunction cellLayoutInfoToDimCell(cellLayoutInfo) {\n  return cellLayoutInfo && (cellLayoutInfo.type === MatrixCellLayoutInfoType.leaf || cellLayoutInfo.type === MatrixCellLayoutInfoType.nonLeaf) ? cellLayoutInfo : null;\n}\nexport function createNaNRectLike() {\n  return {\n    x: NaN,\n    y: NaN,\n    width: NaN,\n    height: NaN\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}