{"ast":null,"code":"import * as matrix from './matrix.js';\nimport Point from './Point.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar XY = ['x', 'y'];\nvar WH = ['width', 'height'];\nvar lt = new Point();\nvar rb = new Point();\nvar lb = new Point();\nvar rt = new Point();\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar _lenMinMax = [0, 0];\nvar BoundingRect = function () {\n  function BoundingRect(x, y, width, height) {\n    BoundingRect.set(this, x, y, width, height);\n  }\n  BoundingRect.set = function (target, x, y, width, height) {\n    if (width < 0) {\n      x = x + width;\n      width = -width;\n    }\n    if (height < 0) {\n      y = y + height;\n      height = -height;\n    }\n    target.x = x;\n    target.y = y;\n    target.width = width;\n    target.height = height;\n    return target;\n  };\n  BoundingRect.prototype.union = function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    if (isFinite(this.x) && isFinite(this.width)) {\n      this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    } else {\n      this.width = other.width;\n    }\n    if (isFinite(this.y) && isFinite(this.height)) {\n      this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    } else {\n      this.height = other.height;\n    }\n    this.x = x;\n    this.y = y;\n  };\n  BoundingRect.prototype.applyTransform = function (m) {\n    BoundingRect.applyTransform(this, this, m);\n  };\n  BoundingRect.prototype.calculateTransform = function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create();\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  };\n  BoundingRect.prototype.intersect = function (b, mtv, opt) {\n    return BoundingRect.intersect(this, b, mtv, opt);\n  };\n  BoundingRect.intersect = function (a, b, mtv, opt) {\n    if (mtv) {\n      Point.set(mtv, 0, 0);\n    }\n    var outIntersectRect = opt && opt.outIntersectRect || null;\n    var clamp = opt && opt.clamp;\n    if (outIntersectRect) {\n      outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;\n    }\n    if (!a || !b) {\n      return false;\n    }\n    if (!(a instanceof BoundingRect)) {\n      a = BoundingRect.set(_tmpIntersectA, a.x, a.y, a.width, a.height);\n    }\n    if (!(b instanceof BoundingRect)) {\n      b = BoundingRect.set(_tmpIntersectB, b.x, b.y, b.width, b.height);\n    }\n    var useMTV = !!mtv;\n    _intersectCtx.reset(opt, useMTV);\n    var touchThreshold = _intersectCtx.touchThreshold;\n    var ax0 = a.x + touchThreshold;\n    var ax1 = a.x + a.width - touchThreshold;\n    var ay0 = a.y + touchThreshold;\n    var ay1 = a.y + a.height - touchThreshold;\n    var bx0 = b.x + touchThreshold;\n    var bx1 = b.x + b.width - touchThreshold;\n    var by0 = b.y + touchThreshold;\n    var by1 = b.y + b.height - touchThreshold;\n    if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) {\n      return false;\n    }\n    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n    if (useMTV || outIntersectRect) {\n      _lenMinMax[0] = Infinity;\n      _lenMinMax[1] = 0;\n      intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp);\n      intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp);\n      if (useMTV) {\n        Point.copy(mtv, overlap ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);\n      }\n    }\n    return overlap;\n  };\n  BoundingRect.contain = function (rect, x, y) {\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  };\n  BoundingRect.prototype.contain = function (x, y) {\n    return BoundingRect.contain(this, x, y);\n  };\n  BoundingRect.prototype.clone = function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  };\n  BoundingRect.prototype.copy = function (other) {\n    BoundingRect.copy(this, other);\n  };\n  BoundingRect.prototype.plain = function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  };\n  BoundingRect.prototype.isFinite = function () {\n    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n  };\n  BoundingRect.prototype.isZero = function () {\n    return this.width === 0 || this.height === 0;\n  };\n  BoundingRect.create = function (rect) {\n    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n  };\n  BoundingRect.copy = function (target, source) {\n    target.x = source.x;\n    target.y = source.y;\n    target.width = source.width;\n    target.height = source.height;\n    return target;\n  };\n  BoundingRect.applyTransform = function (target, source, m) {\n    if (!m) {\n      if (target !== source) {\n        BoundingRect.copy(target, source);\n      }\n      return;\n    }\n    if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n      var sx = m[0];\n      var sy = m[3];\n      var tx = m[4];\n      var ty = m[5];\n      target.x = source.x * sx + tx;\n      target.y = source.y * sy + ty;\n      target.width = source.width * sx;\n      target.height = source.height * sy;\n      if (target.width < 0) {\n        target.x += target.width;\n        target.width = -target.width;\n      }\n      if (target.height < 0) {\n        target.y += target.height;\n        target.height = -target.height;\n      }\n      return;\n    }\n    lt.x = lb.x = source.x;\n    lt.y = rt.y = source.y;\n    rb.x = rt.x = source.x + source.width;\n    rb.y = lb.y = source.y + source.height;\n    lt.transform(m);\n    rt.transform(m);\n    rb.transform(m);\n    lb.transform(m);\n    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n    var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n    var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n    target.width = maxX - target.x;\n    target.height = maxY - target.y;\n  };\n  return BoundingRect;\n}();\nvar _tmpIntersectA = new BoundingRect(0, 0, 0, 0);\nvar _tmpIntersectB = new BoundingRect(0, 0, 0, 0);\nfunction intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp) {\n  var d0 = mathAbs(a1 - b0);\n  var d1 = mathAbs(b1 - a0);\n  var d01min = mathMin(d0, d1);\n  var updateDim = XY[updateDimIdx];\n  var zeroDim = XY[1 - updateDimIdx];\n  var wh = WH[updateDimIdx];\n  if (a1 < b0 || b1 < a0) {\n    if (d0 < d1) {\n      if (useMTV) {\n        _maxTv[updateDim] = -d0;\n      }\n      if (clamp) {\n        outIntersectRect[updateDim] = a1;\n        outIntersectRect[wh] = 0;\n      }\n    } else {\n      if (useMTV) {\n        _maxTv[updateDim] = d1;\n      }\n      if (clamp) {\n        outIntersectRect[updateDim] = a0;\n        outIntersectRect[wh] = 0;\n      }\n    }\n  } else {\n    if (outIntersectRect) {\n      outIntersectRect[updateDim] = mathMax(a0, b0);\n      outIntersectRect[wh] = mathMin(a1, b1) - outIntersectRect[updateDim];\n    }\n    if (useMTV) {\n      if (d01min < _lenMinMax[0] || _intersectCtx.useDir) {\n        _lenMinMax[0] = mathMin(d01min, _lenMinMax[0]);\n        if (d0 < d1 || !_intersectCtx.bidirectional) {\n          _minTv[updateDim] = d0;\n          _minTv[zeroDim] = 0;\n          if (_intersectCtx.useDir) {\n            _intersectCtx.calcDirMTV();\n          }\n        }\n        if (d0 >= d1 || !_intersectCtx.bidirectional) {\n          _minTv[updateDim] = -d1;\n          _minTv[zeroDim] = 0;\n          if (_intersectCtx.useDir) {\n            _intersectCtx.calcDirMTV();\n          }\n        }\n      }\n    }\n  }\n}\nexport function createIntersectContext() {\n  var _direction = 0;\n  var _dirCheckVec = new Point();\n  var _dirTmp = new Point();\n  var _ctx = {\n    minTv: new Point(),\n    maxTv: new Point(),\n    useDir: false,\n    dirMinTv: new Point(),\n    touchThreshold: 0,\n    bidirectional: true,\n    negativeSize: false,\n    reset: function (opt, useMTV) {\n      _ctx.touchThreshold = 0;\n      if (opt && opt.touchThreshold != null) {\n        _ctx.touchThreshold = mathMax(0, opt.touchThreshold);\n      }\n      _ctx.negativeSize = false;\n      if (!useMTV) {\n        return;\n      }\n      _ctx.minTv.set(Infinity, Infinity);\n      _ctx.maxTv.set(0, 0);\n      _ctx.useDir = false;\n      if (opt && opt.direction != null) {\n        _ctx.useDir = true;\n        _ctx.dirMinTv.copy(_ctx.minTv);\n        _dirTmp.copy(_ctx.minTv);\n        _direction = opt.direction;\n        _ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;\n        if (!_ctx.bidirectional) {\n          _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));\n        }\n      }\n    },\n    calcDirMTV: function () {\n      var minTv = _ctx.minTv;\n      var dirMinTv = _ctx.dirMinTv;\n      var squareMag = minTv.y * minTv.y + minTv.x * minTv.x;\n      var dirSin = Math.sin(_direction);\n      var dirCos = Math.cos(_direction);\n      var dotProd = dirSin * minTv.y + dirCos * minTv.x;\n      if (nearZero(dotProd)) {\n        if (nearZero(minTv.x) && nearZero(minTv.y)) {\n          dirMinTv.set(0, 0);\n        }\n        return;\n      }\n      _dirTmp.x = squareMag * dirCos / dotProd;\n      _dirTmp.y = squareMag * dirSin / dotProd;\n      if (nearZero(_dirTmp.x) && nearZero(_dirTmp.y)) {\n        dirMinTv.set(0, 0);\n        return;\n      }\n      if ((_ctx.bidirectional || _dirCheckVec.dot(_dirTmp) > 0) && _dirTmp.len() < dirMinTv.len()) {\n        dirMinTv.copy(_dirTmp);\n      }\n    }\n  };\n  function nearZero(val) {\n    return mathAbs(val) < 1e-10;\n  }\n  return _ctx;\n}\nexport default BoundingRect;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}