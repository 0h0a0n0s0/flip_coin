{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport SymbolDraw from '../helper/SymbolDraw.js';\nimport LineDraw from '../helper/LineDraw.js';\nimport RoamController from '../../component/helper/RoamController.js';\nimport { updateViewOnZoom, updateViewOnPan } from '../../component/helper/roamHelper.js';\nimport * as graphic from '../../util/graphic.js';\nimport adjustEdge from './adjustEdge.js';\nimport { getNodeGlobalScale } from './graphHelper.js';\nimport ChartView from '../../view/Chart.js';\nimport { getECData } from '../../util/innerStore.js';\nimport { simpleLayoutEdge } from './simpleLayoutHelper.js';\nimport { circularLayout, rotateNodeLabel } from './circularLayoutHelper.js';\nimport { clone, extend } from 'zrender/lib/core/util.js';\nimport ECLinePath from '../helper/LinePath.js';\nimport { getThumbnailBridge } from '../../component/helper/thumbnailBridge.js';\nfunction isViewCoordSys(coordSys) {\n  return coordSys.type === 'view';\n}\nvar GraphView = /** @class */function (_super) {\n  __extends(GraphView, _super);\n  function GraphView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = GraphView.type;\n    return _this;\n  }\n  GraphView.prototype.init = function (ecModel, api) {\n    var symbolDraw = new SymbolDraw();\n    var lineDraw = new LineDraw();\n    var group = this.group;\n    var mainGroup = new graphic.Group();\n    this._controller = new RoamController(api.getZr());\n    this._controllerHost = {\n      target: mainGroup\n    };\n    mainGroup.add(symbolDraw.group);\n    mainGroup.add(lineDraw.group);\n    group.add(mainGroup);\n    this._symbolDraw = symbolDraw;\n    this._lineDraw = lineDraw;\n    this._mainGroup = mainGroup;\n    this._firstRender = true;\n  };\n  GraphView.prototype.render = function (seriesModel, ecModel, api) {\n    var _this = this;\n    var coordSys = seriesModel.coordinateSystem;\n    var isForceLayout = false;\n    this._model = seriesModel;\n    this._api = api;\n    this._active = true;\n    var thumbnailInfo = this._getThumbnailInfo();\n    if (thumbnailInfo) {\n      thumbnailInfo.bridge.reset(api);\n    }\n    var symbolDraw = this._symbolDraw;\n    var lineDraw = this._lineDraw;\n    if (isViewCoordSys(coordSys)) {\n      var groupNewProp = {\n        x: coordSys.x,\n        y: coordSys.y,\n        scaleX: coordSys.scaleX,\n        scaleY: coordSys.scaleY\n      };\n      if (this._firstRender) {\n        this._mainGroup.attr(groupNewProp);\n      } else {\n        graphic.updateProps(this._mainGroup, groupNewProp, seriesModel);\n      }\n    }\n    // Fix edge contact point with node\n    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n    var data = seriesModel.getData();\n    symbolDraw.updateData(data);\n    var edgeData = seriesModel.getEdgeData();\n    // TODO: TYPE\n    lineDraw.updateData(edgeData);\n    this._updateNodeAndLinkScale();\n    this._updateController(null, seriesModel, api);\n    clearTimeout(this._layoutTimeout);\n    var forceLayout = seriesModel.forceLayout;\n    var layoutAnimation = seriesModel.get(['force', 'layoutAnimation']);\n    if (forceLayout) {\n      isForceLayout = true;\n      this._startForceLayoutIteration(forceLayout, api, layoutAnimation);\n    }\n    var layout = seriesModel.get('layout');\n    data.graph.eachNode(function (node) {\n      var idx = node.dataIndex;\n      var el = node.getGraphicEl();\n      var itemModel = node.getModel();\n      if (!el) {\n        return;\n      }\n      // Update draggable\n      el.off('drag').off('dragend');\n      var draggable = itemModel.get('draggable');\n      if (draggable) {\n        el.on('drag', function (e) {\n          switch (layout) {\n            case 'force':\n              forceLayout.warmUp();\n              !_this._layouting && _this._startForceLayoutIteration(forceLayout, api, layoutAnimation);\n              forceLayout.setFixed(idx);\n              // Write position back to layout\n              data.setItemLayout(idx, [el.x, el.y]);\n              break;\n            case 'circular':\n              data.setItemLayout(idx, [el.x, el.y]);\n              // mark node fixed\n              node.setLayout({\n                fixed: true\n              }, true);\n              // recalculate circular layout\n              circularLayout(seriesModel, 'symbolSize', node, [e.offsetX, e.offsetY]);\n              _this.updateLayout(seriesModel);\n              break;\n            case 'none':\n            default:\n              data.setItemLayout(idx, [el.x, el.y]);\n              // update edge\n              simpleLayoutEdge(seriesModel.getGraph(), seriesModel);\n              _this.updateLayout(seriesModel);\n              break;\n          }\n        }).on('dragend', function () {\n          if (forceLayout) {\n            forceLayout.setUnfixed(idx);\n          }\n        });\n      }\n      el.setDraggable(draggable, !!itemModel.get('cursor'));\n      var focus = itemModel.get(['emphasis', 'focus']);\n      if (focus === 'adjacency') {\n        getECData(el).focus = node.getAdjacentDataIndices();\n      }\n    });\n    data.graph.eachEdge(function (edge) {\n      var el = edge.getGraphicEl();\n      var focus = edge.getModel().get(['emphasis', 'focus']);\n      if (!el) {\n        return;\n      }\n      if (focus === 'adjacency') {\n        getECData(el).focus = {\n          edge: [edge.dataIndex],\n          node: [edge.node1.dataIndex, edge.node2.dataIndex]\n        };\n      }\n    });\n    var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get(['circular', 'rotateLabel']);\n    var cx = data.getLayout('cx');\n    var cy = data.getLayout('cy');\n    data.graph.eachNode(function (node) {\n      rotateNodeLabel(node, circularRotateLabel, cx, cy);\n    });\n    this._firstRender = false;\n    // Force layout will render thumbnail when layout is finished.\n    if (!isForceLayout) {\n      this._renderThumbnail(seriesModel, api, this._symbolDraw, this._lineDraw);\n    }\n  };\n  GraphView.prototype.dispose = function () {\n    this.remove();\n    this._controller && this._controller.dispose();\n    this._controllerHost = null;\n  };\n  GraphView.prototype._startForceLayoutIteration = function (forceLayout, api, layoutAnimation) {\n    var self = this;\n    var firstRendered = false;\n    (function step() {\n      forceLayout.step(function (stopped) {\n        self.updateLayout(self._model);\n        if (stopped || !firstRendered) {\n          firstRendered = true;\n          self._renderThumbnail(self._model, api, self._symbolDraw, self._lineDraw);\n        }\n        (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());\n      });\n    })();\n  };\n  GraphView.prototype._updateController = function (clipRect, seriesModel, api) {\n    var controller = this._controller;\n    var controllerHost = this._controllerHost;\n    var coordSys = seriesModel.coordinateSystem;\n    if (!isViewCoordSys(coordSys)) {\n      controller.disable();\n      return;\n    }\n    controller.enable(seriesModel.get('roam'), {\n      api: api,\n      zInfo: {\n        component: seriesModel\n      },\n      triggerInfo: {\n        roamTrigger: seriesModel.get('roamTrigger'),\n        isInSelf: function (e, x, y) {\n          return coordSys.containPoint([x, y]);\n        },\n        isInClip: function (e, x, y) {\n          return !clipRect || clipRect.contain(x, y);\n        }\n      }\n    });\n    controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n    controllerHost.zoom = coordSys.getZoom();\n    controller.off('pan').off('zoom').on('pan', function (e) {\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'graphRoam',\n        dx: e.dx,\n        dy: e.dy\n      });\n    }).on('zoom', function (e) {\n      api.dispatchAction({\n        seriesId: seriesModel.id,\n        type: 'graphRoam',\n        zoom: e.scale,\n        originX: e.originX,\n        originY: e.originY\n      });\n    });\n  };\n  /**\n   * A performance shortcut - called by action handler to update the view directly\n   * without any data/visual processing (which are assumed to be unchanged), while\n   * ensuring consistent behavior between internal and external action triggers.\n   */\n  GraphView.prototype.updateViewOnPan = function (seriesModel, api, params) {\n    if (!this._active) {\n      return;\n    }\n    updateViewOnPan(this._controllerHost, params.dx, params.dy);\n    this._updateThumbnailWindow();\n  };\n  /**\n   * A performance shortcut - called by action handler to update the view directly\n   * without any data/visual processing (which are assumed to be unchanged), while\n   * ensuring consistent behavior between internal and external action triggers.\n   */\n  GraphView.prototype.updateViewOnZoom = function (seriesModel, api, params) {\n    if (!this._active) {\n      return;\n    }\n    updateViewOnZoom(this._controllerHost, params.zoom, params.originX, params.originY);\n    this._updateNodeAndLinkScale();\n    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n    this._lineDraw.updateLayout();\n    // Only update label layout on zoom\n    api.updateLabelLayout();\n    this._updateThumbnailWindow();\n  };\n  GraphView.prototype._updateNodeAndLinkScale = function () {\n    var seriesModel = this._model;\n    var data = seriesModel.getData();\n    var nodeScale = getNodeGlobalScale(seriesModel);\n    data.eachItemGraphicEl(function (el, idx) {\n      el && el.setSymbolScale(nodeScale);\n    });\n  };\n  GraphView.prototype.updateLayout = function (seriesModel) {\n    if (!this._active) {\n      return;\n    }\n    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n    this._symbolDraw.updateLayout();\n    this._lineDraw.updateLayout();\n  };\n  GraphView.prototype.remove = function () {\n    this._active = false;\n    clearTimeout(this._layoutTimeout);\n    this._layouting = false;\n    this._layoutTimeout = null;\n    this._symbolDraw && this._symbolDraw.remove();\n    this._lineDraw && this._lineDraw.remove();\n    this._controller && this._controller.disable();\n  };\n  /**\n   * Get thumbnail data structure only if supported.\n   */\n  GraphView.prototype._getThumbnailInfo = function () {\n    var model = this._model;\n    var coordSys = model.coordinateSystem;\n    if (coordSys.type !== 'view') {\n      return;\n    }\n    var bridge = getThumbnailBridge(model);\n    if (!bridge) {\n      return;\n    }\n    return {\n      bridge: bridge,\n      coordSys: coordSys\n    };\n  };\n  GraphView.prototype._updateThumbnailWindow = function () {\n    var info = this._getThumbnailInfo();\n    if (info) {\n      info.bridge.updateWindow(info.coordSys.transform, this._api);\n    }\n  };\n  GraphView.prototype._renderThumbnail = function (seriesModel, api, symbolDraw, lineDraw) {\n    var info = this._getThumbnailInfo();\n    if (!info) {\n      return;\n    }\n    var bridgeGroup = new graphic.Group();\n    var symbolNodes = symbolDraw.group.children();\n    var lineNodes = lineDraw.group.children();\n    var lineGroup = new graphic.Group();\n    var symbolGroup = new graphic.Group();\n    bridgeGroup.add(symbolGroup);\n    bridgeGroup.add(lineGroup);\n    // TODO: reuse elemenents for performance in large graph?\n    for (var i = 0; i < symbolNodes.length; i++) {\n      var node = symbolNodes[i];\n      var sub = node.children()[0];\n      var x = node.x;\n      var y = node.y;\n      var subShape = clone(sub.shape);\n      var shape = extend(subShape, {\n        width: sub.scaleX,\n        height: sub.scaleY,\n        x: x - sub.scaleX / 2,\n        y: y - sub.scaleY / 2\n      });\n      var style = clone(sub.style);\n      var subThumbnail = new sub.constructor({\n        shape: shape,\n        style: style,\n        z2: 151\n      });\n      symbolGroup.add(subThumbnail);\n    }\n    for (var i = 0; i < lineNodes.length; i++) {\n      var node = lineNodes[i];\n      var line = node.children()[0];\n      var style = clone(line.style);\n      var shape = clone(line.shape);\n      var lineThumbnail = new ECLinePath({\n        style: style,\n        shape: shape,\n        z2: 151\n      });\n      lineGroup.add(lineThumbnail);\n    }\n    info.bridge.renderContent({\n      api: api,\n      roamType: seriesModel.get('roam'),\n      viewportRect: null,\n      group: bridgeGroup,\n      targetTrans: info.coordSys.transform\n    });\n  };\n  GraphView.type = 'graph';\n  return GraphView;\n}(ChartView);\nexport default GraphView;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}