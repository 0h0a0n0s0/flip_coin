{"ast":null,"code":"import Point from './Point.js';\nimport { createIntersectContext } from './BoundingRect.js';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathAbs = Math.abs;\nvar _extent = [0, 0];\nvar _extent2 = [0, 0];\nvar _intersectCtx = createIntersectContext();\nvar _minTv = _intersectCtx.minTv;\nvar _maxTv = _intersectCtx.maxTv;\nvar OrientedBoundingRect = function () {\n  function OrientedBoundingRect(rect, transform) {\n    this._corners = [];\n    this._axes = [];\n    this._origin = [0, 0];\n    for (var i = 0; i < 4; i++) {\n      this._corners[i] = new Point();\n    }\n    for (var i = 0; i < 2; i++) {\n      this._axes[i] = new Point();\n    }\n    if (rect) {\n      this.fromBoundingRect(rect, transform);\n    }\n  }\n  OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n    var corners = this._corners;\n    var axes = this._axes;\n    var x = rect.x;\n    var y = rect.y;\n    var x2 = x + rect.width;\n    var y2 = y + rect.height;\n    corners[0].set(x, y);\n    corners[1].set(x2, y);\n    corners[2].set(x2, y2);\n    corners[3].set(x, y2);\n    if (transform) {\n      for (var i = 0; i < 4; i++) {\n        corners[i].transform(transform);\n      }\n    }\n    Point.sub(axes[0], corners[1], corners[0]);\n    Point.sub(axes[1], corners[3], corners[0]);\n    axes[0].normalize();\n    axes[1].normalize();\n    for (var i = 0; i < 2; i++) {\n      this._origin[i] = axes[i].dot(corners[0]);\n    }\n  };\n  OrientedBoundingRect.prototype.intersect = function (other, mtv, opt) {\n    var overlapped = true;\n    var noMtv = !mtv;\n    if (mtv) {\n      Point.set(mtv, 0, 0);\n    }\n    _intersectCtx.reset(opt, !noMtv);\n    if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {\n      overlapped = false;\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n    if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {\n      overlapped = false;\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n    if (!noMtv && !_intersectCtx.negativeSize) {\n      Point.copy(mtv, overlapped ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);\n    }\n    return overlapped;\n  };\n  OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, noMtv, inverse) {\n    var overlapped = true;\n    for (var i = 0; i < 2; i++) {\n      var axis = self._axes[i];\n      self._getProjMinMaxOnAxis(i, self._corners, _extent);\n      self._getProjMinMaxOnAxis(i, other._corners, _extent2);\n      if (_intersectCtx.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {\n        overlapped = false;\n        if (_intersectCtx.negativeSize || noMtv) {\n          return overlapped;\n        }\n        var dist0 = mathAbs(_extent2[0] - _extent[1]);\n        var dist1 = mathAbs(_extent[0] - _extent2[1]);\n        if (mathMin(dist0, dist1) > _maxTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(_maxTv, axis, -dist0 * inverse);\n          } else {\n            Point.scale(_maxTv, axis, dist1 * inverse);\n          }\n        }\n      } else if (!noMtv) {\n        var dist0 = mathAbs(_extent2[0] - _extent[1]);\n        var dist1 = mathAbs(_extent[0] - _extent2[1]);\n        if (_intersectCtx.useDir || mathMin(dist0, dist1) < _minTv.len()) {\n          if (dist0 < dist1 || !_intersectCtx.bidirectional) {\n            Point.scale(_minTv, axis, dist0 * inverse);\n            if (_intersectCtx.useDir) {\n              _intersectCtx.calcDirMTV();\n            }\n          }\n          if (dist0 >= dist1 || !_intersectCtx.bidirectional) {\n            Point.scale(_minTv, axis, -dist1 * inverse);\n            if (_intersectCtx.useDir) {\n              _intersectCtx.calcDirMTV();\n            }\n          }\n        }\n      }\n    }\n    return overlapped;\n  };\n  OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n    var axis = this._axes[dim];\n    var origin = this._origin;\n    var proj = corners[0].dot(axis) + origin[dim];\n    var min = proj;\n    var max = proj;\n    for (var i = 1; i < corners.length; i++) {\n      var proj_1 = corners[i].dot(axis) + origin[dim];\n      min = mathMin(proj_1, min);\n      max = mathMax(proj_1, max);\n    }\n    out[0] = min + _intersectCtx.touchThreshold;\n    out[1] = max - _intersectCtx.touchThreshold;\n    _intersectCtx.negativeSize = out[1] < out[0];\n  };\n  return OrientedBoundingRect;\n}();\nexport default OrientedBoundingRect;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}