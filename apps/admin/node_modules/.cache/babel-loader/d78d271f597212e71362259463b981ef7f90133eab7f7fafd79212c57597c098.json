{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { extend, retrieve3 } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getSectorCornerRadius } from '../helper/sectorHelper.js';\nimport { getLabelStatesModels, setLabelStyle } from '../../label/labelStyle.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { getECData } from '../../util/innerStore.js';\nvar ChordPiece = /** @class */function (_super) {\n  __extends(ChordPiece, _super);\n  function ChordPiece(data, idx, startAngle) {\n    var _this = _super.call(this) || this;\n    getECData(_this).dataType = 'node';\n    _this.z2 = 2;\n    var text = new graphic.Text();\n    _this.setTextContent(text);\n    _this.updateData(data, idx, startAngle, true);\n    return _this;\n  }\n  ChordPiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {\n    var sector = this;\n    var node = data.graph.getNodeByIndex(idx);\n    var seriesModel = data.hostModel;\n    var itemModel = node.getModel();\n    var emphasisModel = itemModel.getModel('emphasis');\n    // layout position is the center of the sector\n    var layout = data.getItemLayout(idx);\n    var shape = extend(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout, true), layout);\n    var el = this;\n    // Ignore NaN data.\n    if (isNaN(shape.startAngle)) {\n      // Use NaN shape to avoid drawing shape.\n      el.setShape(shape);\n      return;\n    }\n    if (firstCreate) {\n      el.setShape(shape);\n    } else {\n      graphic.updateProps(el, {\n        shape: shape\n      }, seriesModel, idx);\n    }\n    var sectorShape = extend(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout, true), layout);\n    sector.setShape(sectorShape);\n    sector.useStyle(data.getItemVisual(idx, 'style'));\n    setStatesStylesFromModel(sector, itemModel);\n    this._updateLabel(seriesModel, itemModel, node);\n    data.setItemGraphicEl(idx, el);\n    setStatesStylesFromModel(el, itemModel, 'itemStyle');\n    // Add focus/blur states handling\n    var focus = emphasisModel.get('focus');\n    toggleHoverEmphasis(this, focus === 'adjacency' ? node.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n  };\n  ChordPiece.prototype._updateLabel = function (seriesModel, itemModel, node) {\n    var label = this.getTextContent();\n    var layout = node.getLayout();\n    var midAngle = (layout.startAngle + layout.endAngle) / 2;\n    var dx = Math.cos(midAngle);\n    var dy = Math.sin(midAngle);\n    var normalLabelModel = itemModel.getModel('label');\n    label.ignore = !normalLabelModel.get('show');\n    // Set label style\n    var labelStateModels = getLabelStatesModels(itemModel);\n    var style = node.getVisual('style');\n    setLabelStyle(label, labelStateModels, {\n      labelFetcher: {\n        getFormattedLabel: function (dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {\n          return seriesModel.getFormattedLabel(dataIndex, stateName, 'node', labelDimIndex,\n          // ensure edgeLabel formatter is provided\n          // to prevent the inheritance from `label.formatter` of the series\n          retrieve3(formatter, labelStateModels.normal && labelStateModels.normal.get('formatter'), itemModel.get('name')), extendParams);\n        }\n      },\n      labelDataIndex: node.dataIndex,\n      defaultText: node.dataIndex + '',\n      inheritColor: style.fill,\n      defaultOpacity: style.opacity,\n      defaultOutsidePosition: 'startArc'\n    });\n    // Set label position\n    var labelPosition = normalLabelModel.get('position') || 'outside';\n    var labelPadding = normalLabelModel.get('distance') || 0;\n    var r;\n    if (labelPosition === 'outside') {\n      r = layout.r + labelPadding;\n    } else {\n      r = (layout.r + layout.r0) / 2;\n    }\n    this.textConfig = {\n      inside: labelPosition !== 'outside'\n    };\n    var align = labelPosition !== 'outside' ? normalLabelModel.get('align') || 'center' : dx > 0 ? 'left' : 'right';\n    var verticalAlign = labelPosition !== 'outside' ? normalLabelModel.get('verticalAlign') || 'middle' : dy > 0 ? 'top' : 'bottom';\n    label.attr({\n      x: dx * r + layout.cx,\n      y: dy * r + layout.cy,\n      rotation: 0,\n      style: {\n        align: align,\n        verticalAlign: verticalAlign\n      }\n    });\n  };\n  return ChordPiece;\n}(graphic.Sector);\nexport default ChordPiece;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}