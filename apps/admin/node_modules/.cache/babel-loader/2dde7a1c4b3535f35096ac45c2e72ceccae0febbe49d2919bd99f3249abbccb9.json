{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport * as numberUtil from './number.js';\nimport { getDefaultLocaleModel, getLocaleModel, SYSTEM_LANG } from '../core/locale.js';\nimport Model from '../model/Model.js';\nimport { getScaleBreakHelper } from '../scale/break.js';\nexport var ONE_SECOND = 1000;\nexport var ONE_MINUTE = ONE_SECOND * 60;\nexport var ONE_HOUR = ONE_MINUTE * 60;\nexport var ONE_DAY = ONE_HOUR * 24;\nexport var ONE_YEAR = ONE_DAY * 365;\nvar primaryTimeUnitFormatterMatchers = {\n  year: /({yyyy}|{yy})/,\n  month: /({MMMM}|{MMM}|{MM}|{M})/,\n  day: /({dd}|{d})/,\n  hour: /({HH}|{H}|{hh}|{h})/,\n  minute: /({mm}|{m})/,\n  second: /({ss}|{s})/,\n  millisecond: /({SSS}|{S})/\n};\nvar defaultFormatterSeed = {\n  year: '{yyyy}',\n  month: '{MMM}',\n  day: '{d}',\n  hour: '{HH}:{mm}',\n  minute: '{HH}:{mm}',\n  second: '{HH}:{mm}:{ss}',\n  millisecond: '{HH}:{mm}:{ss} {SSS}'\n};\nvar defaultFullFormatter = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}';\nvar fullDayFormatter = '{yyyy}-{MM}-{dd}';\nexport var fullLeveledFormatter = {\n  year: '{yyyy}',\n  month: '{yyyy}-{MM}',\n  day: fullDayFormatter,\n  hour: fullDayFormatter + ' ' + defaultFormatterSeed.hour,\n  minute: fullDayFormatter + ' ' + defaultFormatterSeed.minute,\n  second: fullDayFormatter + ' ' + defaultFormatterSeed.second,\n  millisecond: defaultFullFormatter\n};\n// Order must be ensured from big to small.\nexport var primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];\nexport var timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond'];\nexport function parseTimeAxisLabelFormatter(formatter) {\n  // Keep the logic the same with function `leveledFormat`.\n  return !zrUtil.isString(formatter) && !zrUtil.isFunction(formatter) ? parseTimeAxisLabelFormatterDictionary(formatter) : formatter;\n}\n/**\n * The final generated dictionary is like:\n *  generated_dict = {\n *      year: {\n *          year: ['{yyyy}', ...<higher_levels_if_any>]\n *      },\n *      month: {\n *          year: ['{yyyy} {MMM}', ...<higher_levels_if_any>],\n *          month: ['{MMM}', ...<higher_levels_if_any>]\n *      },\n *      day: {\n *          year: ['{yyyy} {MMM} {d}', ...<higher_levels_if_any>],\n *          month: ['{MMM} {d}', ...<higher_levels_if_any>],\n *          day: ['{d}', ...<higher_levels_if_any>]\n *      },\n *      ...\n *  }\n *\n * In echarts option, users can specify the entire dictionary or typically just:\n *  {formatter: {\n *      year: '{yyyy}', // Or an array of leveled templates: `['{yyyy}', '{bold1|{yyyy}}', ...]`,\n *                      // corresponding to `[level0, level1, level2, ...]`.\n *      month: '{MMM}',\n *      day: '{d}',\n *      hour: '{HH}:{mm}',\n *      second: '{HH}:{mm}',\n *      ...\n *  }}\n *  If any time unit is not specified in echarts option, the default template is used,\n *  such as `['{yyyy}', {primary|{yyyy}']`.\n *\n * The `tick.level` is only used to read string from each array, meaning the style type.\n *\n * Let `lowerUnit = getUnitFromValue(tick.value)`.\n * The non-break axis ticks only use `generated_dict[lowerUnit][lowerUnit][level]`.\n * The break axis ticks may use `generated_dict[lowerUnit][upperUnit][level]`, because:\n *  Consider the case: the non-break ticks are `16th, 23th, Feb, 7th, ...`, where `Feb` is in the break\n *  range and pruned by breaks, and the break ends might be in lower time unit than day. e.g., break start\n *  is `Jan 25th 18:00`(in unit `hour`) and break end is `Feb 6th 18:30` (in unit `minute`). Thus the break\n *  label prefers `Jan 25th 18:00` and `Feb 6th 18:30` rather than only `18:00` and `18:30`, otherwise it\n *  causes misleading.\n *  In this case, the tick of the break start and end will both be:\n *      `{level: 1, lowerTimeUnit: 'minute', upperTimeUnit: 'month'}`\n *  And get the final template by `generated_dict[lowerTimeUnit][upperTimeUnit][level]`.\n *  Note that the time unit can not be calculated directly by a single tick value, since the two breaks have\n *  to be at the same time unit to avoid awkward appearance. i.e., `Jan 25th 18:00` is in the time unit \"hour\"\n *  but we need it to be \"minute\", following `Feb 6th 18:30`.\n */\nfunction parseTimeAxisLabelFormatterDictionary(dictOption) {\n  dictOption = dictOption || {};\n  var dict = {};\n  // Currently if any template is specified by user, it may contain rich text tag,\n  // such as `'{my_bold|{YYYY}}'`, thus we do add highlight style to it.\n  // (Note that nested tag (`'{some|{some2|xxx}}'`) in rich text is not supported yet.)\n  var canAddHighlight = true;\n  zrUtil.each(primaryTimeUnits, function (lowestUnit) {\n    canAddHighlight && (canAddHighlight = dictOption[lowestUnit] == null);\n  });\n  zrUtil.each(primaryTimeUnits, function (lowestUnit, lowestUnitIdx) {\n    var upperDictOption = dictOption[lowestUnit];\n    dict[lowestUnit] = {};\n    var lowerTpl = null;\n    for (var upperUnitIdx = lowestUnitIdx; upperUnitIdx >= 0; upperUnitIdx--) {\n      var upperUnit = primaryTimeUnits[upperUnitIdx];\n      var upperDictItemOption = zrUtil.isObject(upperDictOption) && !zrUtil.isArray(upperDictOption) ? upperDictOption[upperUnit] : upperDictOption;\n      var tplArr = void 0;\n      if (zrUtil.isArray(upperDictItemOption)) {\n        tplArr = upperDictItemOption.slice();\n        lowerTpl = tplArr[0] || '';\n      } else if (zrUtil.isString(upperDictItemOption)) {\n        lowerTpl = upperDictItemOption;\n        tplArr = [lowerTpl];\n      } else {\n        if (lowerTpl == null) {\n          lowerTpl = defaultFormatterSeed[lowestUnit];\n        }\n        // Generate the dict by the rule as follows:\n        // If the user specify (or by default):\n        //  {formatter: {\n        //      year: '{yyyy}',\n        //      month: '{MMM}',\n        //      day: '{d}',\n        //      ...\n        //  }}\n        // Concat them to make the final dictionary:\n        //  {formatter: {\n        //      year: {year: ['{yyyy}']},\n        //      month: {year: ['{yyyy} {MMM}'], month: ['{MMM}']},\n        //      day: {year: ['{yyyy} {MMM} {d}'], month: ['{MMM} {d}'], day: ['{d}']}\n        //      ...\n        //  }}\n        // And then add `{primary|...}` to each array if from default template.\n        // This strategy is convinient for user configurating and works for most cases.\n        // If bad cases encountered, users can specify the entire dictionary themselves\n        // instead of going through this logic.\n        else if (!primaryTimeUnitFormatterMatchers[upperUnit].test(lowerTpl)) {\n          lowerTpl = dict[upperUnit][upperUnit][0] + \" \" + lowerTpl;\n        }\n        tplArr = [lowerTpl];\n        if (canAddHighlight) {\n          tplArr[1] = \"{primary|\" + lowerTpl + \"}\";\n        }\n      }\n      dict[lowestUnit][upperUnit] = tplArr;\n    }\n  });\n  return dict;\n}\nexport function pad(str, len) {\n  str += '';\n  return '0000'.substr(0, len - str.length) + str;\n}\nexport function getPrimaryTimeUnit(timeUnit) {\n  switch (timeUnit) {\n    case 'half-year':\n    case 'quarter':\n      return 'month';\n    case 'week':\n    case 'half-week':\n      return 'day';\n    case 'half-day':\n    case 'quarter-day':\n      return 'hour';\n    default:\n      // year, minutes, second, milliseconds\n      return timeUnit;\n  }\n}\nexport function isPrimaryTimeUnit(timeUnit) {\n  return timeUnit === getPrimaryTimeUnit(timeUnit);\n}\nexport function getDefaultFormatPrecisionOfInterval(timeUnit) {\n  switch (timeUnit) {\n    case 'year':\n    case 'month':\n      return 'day';\n    case 'millisecond':\n      return 'millisecond';\n    default:\n      // Also for day, hour, minute, second\n      return 'second';\n  }\n}\nexport function format(\n// Note: The result based on `isUTC` are totally different, which can not be just simply\n// substituted by the result without `isUTC`. So we make the param `isUTC` mandatory.\ntime, template, isUTC, lang) {\n  var date = numberUtil.parseDate(time);\n  var y = date[fullYearGetterName(isUTC)]();\n  var M = date[monthGetterName(isUTC)]() + 1;\n  var q = Math.floor((M - 1) / 3) + 1;\n  var d = date[dateGetterName(isUTC)]();\n  var e = date['get' + (isUTC ? 'UTC' : '') + 'Day']();\n  var H = date[hoursGetterName(isUTC)]();\n  var h = (H - 1) % 12 + 1;\n  var m = date[minutesGetterName(isUTC)]();\n  var s = date[secondsGetterName(isUTC)]();\n  var S = date[millisecondsGetterName(isUTC)]();\n  var a = H >= 12 ? 'pm' : 'am';\n  var A = a.toUpperCase();\n  var localeModel = lang instanceof Model ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();\n  var timeModel = localeModel.getModel('time');\n  var month = timeModel.get('month');\n  var monthAbbr = timeModel.get('monthAbbr');\n  var dayOfWeek = timeModel.get('dayOfWeek');\n  var dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr');\n  return (template || '').replace(/{a}/g, a + '').replace(/{A}/g, A + '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, pad(y % 100 + '', 2)).replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '');\n}\nexport function leveledFormat(tick, idx, formatter, lang, isUTC) {\n  var template = null;\n  if (zrUtil.isString(formatter)) {\n    // Single formatter for all units at all levels\n    template = formatter;\n  } else if (zrUtil.isFunction(formatter)) {\n    var extra = {\n      time: tick.time,\n      level: tick.time.level\n    };\n    var scaleBreakHelper = getScaleBreakHelper();\n    if (scaleBreakHelper) {\n      scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick[\"break\"]);\n    }\n    template = formatter(tick.value, idx, extra);\n  } else {\n    var tickTime = tick.time;\n    if (tickTime) {\n      var leveledTplArr = formatter[tickTime.lowerTimeUnit][tickTime.upperTimeUnit];\n      template = leveledTplArr[Math.min(tickTime.level, leveledTplArr.length - 1)] || '';\n    } else {\n      // tick may be from customTicks or timeline therefore no tick.time.\n      var unit = getUnitFromValue(tick.value, isUTC);\n      template = formatter[unit][unit][0];\n    }\n  }\n  return format(new Date(tick.value), template, isUTC, lang);\n}\nexport function getUnitFromValue(value, isUTC) {\n  var date = numberUtil.parseDate(value);\n  var M = date[monthGetterName(isUTC)]() + 1;\n  var d = date[dateGetterName(isUTC)]();\n  var h = date[hoursGetterName(isUTC)]();\n  var m = date[minutesGetterName(isUTC)]();\n  var s = date[secondsGetterName(isUTC)]();\n  var S = date[millisecondsGetterName(isUTC)]();\n  var isSecond = S === 0;\n  var isMinute = isSecond && s === 0;\n  var isHour = isMinute && m === 0;\n  var isDay = isHour && h === 0;\n  var isMonth = isDay && d === 1;\n  var isYear = isMonth && M === 1;\n  if (isYear) {\n    return 'year';\n  } else if (isMonth) {\n    return 'month';\n  } else if (isDay) {\n    return 'day';\n  } else if (isHour) {\n    return 'hour';\n  } else if (isMinute) {\n    return 'minute';\n  } else if (isSecond) {\n    return 'second';\n  } else {\n    return 'millisecond';\n  }\n}\n// export function getUnitValue(\n//     value: number | Date,\n//     unit: TimeUnit,\n//     isUTC: boolean\n// ) : number {\n//     const date = zrUtil.isNumber(value)\n//         ? numberUtil.parseDate(value)\n//         : value;\n//     unit = unit || getUnitFromValue(value, isUTC);\n//     switch (unit) {\n//         case 'year':\n//             return date[fullYearGetterName(isUTC)]();\n//         case 'half-year':\n//             return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;\n//         case 'quarter':\n//             return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);\n//         case 'month':\n//             return date[monthGetterName(isUTC)]();\n//         case 'day':\n//             return date[dateGetterName(isUTC)]();\n//         case 'half-day':\n//             return date[hoursGetterName(isUTC)]() / 24;\n//         case 'hour':\n//             return date[hoursGetterName(isUTC)]();\n//         case 'minute':\n//             return date[minutesGetterName(isUTC)]();\n//         case 'second':\n//             return date[secondsGetterName(isUTC)]();\n//         case 'millisecond':\n//             return date[millisecondsGetterName(isUTC)]();\n//     }\n// }\n/**\n * e.g.,\n * If timeUnit is 'year', return the Jan 1st 00:00:00 000 of that year.\n * If timeUnit is 'day', return the 00:00:00 000 of that day.\n *\n * @return The input date.\n */\nexport function roundTime(date, timeUnit, isUTC) {\n  switch (timeUnit) {\n    case 'year':\n      date[monthSetterName(isUTC)](0);\n    case 'month':\n      date[dateSetterName(isUTC)](1);\n    case 'day':\n      date[hoursSetterName(isUTC)](0);\n    case 'hour':\n      date[minutesSetterName(isUTC)](0);\n    case 'minute':\n      date[secondsSetterName(isUTC)](0);\n    case 'second':\n      date[millisecondsSetterName(isUTC)](0);\n  }\n  return date;\n}\nexport function fullYearGetterName(isUTC) {\n  return isUTC ? 'getUTCFullYear' : 'getFullYear';\n}\nexport function monthGetterName(isUTC) {\n  return isUTC ? 'getUTCMonth' : 'getMonth';\n}\nexport function dateGetterName(isUTC) {\n  return isUTC ? 'getUTCDate' : 'getDate';\n}\nexport function hoursGetterName(isUTC) {\n  return isUTC ? 'getUTCHours' : 'getHours';\n}\nexport function minutesGetterName(isUTC) {\n  return isUTC ? 'getUTCMinutes' : 'getMinutes';\n}\nexport function secondsGetterName(isUTC) {\n  return isUTC ? 'getUTCSeconds' : 'getSeconds';\n}\nexport function millisecondsGetterName(isUTC) {\n  return isUTC ? 'getUTCMilliseconds' : 'getMilliseconds';\n}\nexport function fullYearSetterName(isUTC) {\n  return isUTC ? 'setUTCFullYear' : 'setFullYear';\n}\nexport function monthSetterName(isUTC) {\n  return isUTC ? 'setUTCMonth' : 'setMonth';\n}\nexport function dateSetterName(isUTC) {\n  return isUTC ? 'setUTCDate' : 'setDate';\n}\nexport function hoursSetterName(isUTC) {\n  return isUTC ? 'setUTCHours' : 'setHours';\n}\nexport function minutesSetterName(isUTC) {\n  return isUTC ? 'setUTCMinutes' : 'setMinutes';\n}\nexport function secondsSetterName(isUTC) {\n  return isUTC ? 'setUTCSeconds' : 'setSeconds';\n}\nexport function millisecondsSetterName(isUTC) {\n  return isUTC ? 'setUTCMilliseconds' : 'setMilliseconds';\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}