{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { normalizeArcAngles } from 'zrender/lib/core/PathProxy.js';\nimport { getCircleLayout } from '../../util/layout.js';\nvar RADIAN = Math.PI / 180;\nexport default function chordCircularLayout(ecModel, api) {\n  ecModel.eachSeriesByType('chord', function (seriesModel) {\n    chordLayout(seriesModel, api);\n  });\n}\nfunction chordLayout(seriesModel, api) {\n  var nodeData = seriesModel.getData();\n  var nodeGraph = nodeData.graph;\n  var edgeData = seriesModel.getEdgeData();\n  var edgeCount = edgeData.count();\n  if (!edgeCount) {\n    return;\n  }\n  var _a = getCircleLayout(seriesModel, api),\n    cx = _a.cx,\n    cy = _a.cy,\n    r = _a.r,\n    r0 = _a.r0;\n  var padAngle = Math.max((seriesModel.get('padAngle') || 0) * RADIAN, 0);\n  var minAngle = Math.max((seriesModel.get('minAngle') || 0) * RADIAN, 0);\n  var startAngle = -seriesModel.get('startAngle') * RADIAN;\n  var endAngle = startAngle + Math.PI * 2;\n  var clockwise = seriesModel.get('clockwise');\n  var dir = clockwise ? 1 : -1;\n  // Normalize angles\n  var angles = [startAngle, endAngle];\n  normalizeArcAngles(angles, !clockwise);\n  var normalizedStartAngle = angles[0],\n    normalizedEndAngle = angles[1];\n  var totalAngle = normalizedEndAngle - normalizedStartAngle;\n  var allZero = nodeData.getSum('value') === 0 && edgeData.getSum('value') === 0;\n  // Sum of each node's edge values\n  var nodeValues = [];\n  var renderedNodeCount = 0;\n  nodeGraph.eachEdge(function (edge) {\n    // All links use the same value 1 when allZero is true\n    var value = allZero ? 1 : edge.getValue('value');\n    if (allZero && (value > 0 || minAngle)) {\n      // When allZero is true, angle is in direct proportion to number\n      // of links both in and out of the node.\n      renderedNodeCount += 2;\n    }\n    var node1Index = edge.node1.dataIndex;\n    var node2Index = edge.node2.dataIndex;\n    nodeValues[node1Index] = (nodeValues[node1Index] || 0) + value;\n    nodeValues[node2Index] = (nodeValues[node2Index] || 0) + value;\n  });\n  // Update nodeValues with data.value if exists\n  var nodeValueSum = 0;\n  nodeGraph.eachNode(function (node) {\n    var dataValue = node.getValue('value');\n    if (!isNaN(dataValue)) {\n      nodeValues[node.dataIndex] = Math.max(dataValue, nodeValues[node.dataIndex] || 0);\n    }\n    if (!allZero && (nodeValues[node.dataIndex] > 0 || minAngle)) {\n      // When allZero is false, angle is in direct proportion to node's\n      // value\n      renderedNodeCount++;\n    }\n    nodeValueSum += nodeValues[node.dataIndex] || 0;\n  });\n  if (renderedNodeCount === 0 || nodeValueSum === 0) {\n    return;\n  }\n  if (padAngle * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the pad, minAngle has higher priority, and padAngle takes the rest\n    padAngle = Math.max(0, (Math.abs(totalAngle) - minAngle * renderedNodeCount) / renderedNodeCount);\n  }\n  if ((padAngle + minAngle) * renderedNodeCount >= Math.abs(totalAngle)) {\n    // Not enough angle to render the minAngle, so ignore the minAngle\n    minAngle = (Math.abs(totalAngle) - padAngle * renderedNodeCount) / renderedNodeCount;\n  }\n  var unitAngle = (totalAngle - padAngle * renderedNodeCount * dir) / nodeValueSum;\n  var totalDeficit = 0; // sum of deficits of nodes with span < minAngle\n  var totalSurplus = 0; // sum of (spans - minAngle) of nodes with span > minAngle\n  var totalSurplusSpan = 0; // sum of spans of nodes with span > minAngle\n  var minSurplus = Infinity; // min of (spans - minAngle) of nodes with span > minAngle\n  nodeGraph.eachNode(function (node) {\n    var value = nodeValues[node.dataIndex] || 0;\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    if (Math.abs(spanAngle) < minAngle) {\n      totalDeficit += minAngle - Math.abs(spanAngle);\n    } else {\n      minSurplus = Math.min(minSurplus, Math.abs(spanAngle) - minAngle);\n      totalSurplus += Math.abs(spanAngle) - minAngle;\n      totalSurplusSpan += Math.abs(spanAngle);\n    }\n    node.setLayout({\n      angle: spanAngle,\n      value: value\n    });\n  });\n  var surplusAsMuchAsPossible = false;\n  if (totalDeficit > totalSurplus) {\n    // Not enough angle to spread the nodes, scale all\n    var scale_1 = totalDeficit / totalSurplus;\n    nodeGraph.eachNode(function (node) {\n      var spanAngle = node.getLayout().angle;\n      if (Math.abs(spanAngle) >= minAngle) {\n        node.setLayout({\n          angle: spanAngle * scale_1,\n          ratio: scale_1\n        }, true);\n      } else {\n        node.setLayout({\n          angle: minAngle,\n          ratio: minAngle === 0 ? 1 : spanAngle / minAngle\n        }, true);\n      }\n    });\n  } else {\n    // For example, if totalDeficit is 60 degrees and totalSurplus is 70\n    // degrees but one of the sector can only reduced by 1 degree,\n    // if we decrease it with the ratio of value to other surplused nodes,\n    // it will have smaller angle than minAngle itself.\n    // So we need to borrow some angle from other nodes.\n    nodeGraph.eachNode(function (node) {\n      if (surplusAsMuchAsPossible) {\n        return;\n      }\n      var spanAngle = node.getLayout().angle;\n      var borrowRatio = Math.min(spanAngle / totalSurplusSpan, 1);\n      var borrowAngle = borrowRatio * totalDeficit;\n      if (spanAngle - borrowAngle < minAngle) {\n        // It will have less than minAngle after borrowing\n        surplusAsMuchAsPossible = true;\n      }\n    });\n  }\n  var restDeficit = totalDeficit;\n  nodeGraph.eachNode(function (node) {\n    if (restDeficit <= 0) {\n      return;\n    }\n    var spanAngle = node.getLayout().angle;\n    if (spanAngle > minAngle && minAngle > 0) {\n      var borrowRatio = surplusAsMuchAsPossible ? 1 : Math.min(spanAngle / totalSurplusSpan, 1);\n      var maxBorrowAngle = spanAngle - minAngle;\n      var borrowAngle = Math.min(maxBorrowAngle, Math.min(restDeficit, totalDeficit * borrowRatio));\n      restDeficit -= borrowAngle;\n      node.setLayout({\n        angle: spanAngle - borrowAngle,\n        ratio: (spanAngle - borrowAngle) / spanAngle\n      }, true);\n    } else if (minAngle > 0) {\n      node.setLayout({\n        angle: minAngle,\n        ratio: spanAngle === 0 ? 1 : minAngle / spanAngle\n      }, true);\n    }\n  });\n  var angle = normalizedStartAngle;\n  var edgeAccAngle = [];\n  nodeGraph.eachNode(function (node) {\n    var spanAngle = Math.max(node.getLayout().angle, minAngle);\n    node.setLayout({\n      cx: cx,\n      cy: cy,\n      r0: r0,\n      r: r,\n      startAngle: angle,\n      endAngle: angle + spanAngle * dir,\n      clockwise: clockwise\n    }, true);\n    edgeAccAngle[node.dataIndex] = angle;\n    angle += (spanAngle + padAngle) * dir;\n  });\n  nodeGraph.eachEdge(function (edge) {\n    var value = allZero ? 1 : edge.getValue('value');\n    var spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir;\n    var node1Index = edge.node1.dataIndex;\n    var sStartAngle = edgeAccAngle[node1Index] || 0;\n    var sSpan = Math.abs((edge.node1.getLayout().ratio || 1) * spanAngle);\n    var sEndAngle = sStartAngle + sSpan * dir;\n    var s1 = [cx + r0 * Math.cos(sStartAngle), cy + r0 * Math.sin(sStartAngle)];\n    var s2 = [cx + r0 * Math.cos(sEndAngle), cy + r0 * Math.sin(sEndAngle)];\n    var node2Index = edge.node2.dataIndex;\n    var tStartAngle = edgeAccAngle[node2Index] || 0;\n    var tSpan = Math.abs((edge.node2.getLayout().ratio || 1) * spanAngle);\n    var tEndAngle = tStartAngle + tSpan * dir;\n    var t1 = [cx + r0 * Math.cos(tStartAngle), cy + r0 * Math.sin(tStartAngle)];\n    var t2 = [cx + r0 * Math.cos(tEndAngle), cy + r0 * Math.sin(tEndAngle)];\n    edge.setLayout({\n      s1: s1,\n      s2: s2,\n      sStartAngle: sStartAngle,\n      sEndAngle: sEndAngle,\n      t1: t1,\n      t2: t2,\n      tStartAngle: tStartAngle,\n      tEndAngle: tEndAngle,\n      cx: cx,\n      cy: cy,\n      r: r0,\n      value: value,\n      clockwise: clockwise\n    });\n    edgeAccAngle[node1Index] = sEndAngle;\n    edgeAccAngle[node2Index] = tEndAngle;\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}