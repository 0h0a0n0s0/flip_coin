{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, defaults, each, eqNaN, isArray, isObject, isString } from 'zrender/lib/core/util.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport OrdinalMeta from '../../data/OrdinalMeta.js';\nimport Ordinal from '../../scale/Ordinal.js';\nimport { WH, XY } from '../../util/graphic.js';\nimport { ListIterator } from '../../util/model.js';\nimport { createNaNRectLike, setDimXYValue, MatrixCellLayoutInfoType } from './matrixCoordHelper.js';\nimport { error } from '../../util/log.js';\nimport { mathMax } from '../../util/number.js';\n/**\n * Lifetime: the same with `MatrixModel`, but different from `coord/Matrix`.\n */\nvar MatrixDim = /** @class */function () {\n  function MatrixDim(dim, dimModel) {\n    // Under the current definition, every leave corresponds a unit cell,\n    // and leaves can serve as the locator of cells.\n    // Therefore make sure:\n    //  - The first `_leavesCount` elements in `_cells` are leaves.\n    //  - `_cells[leaf.id[XY[this.dimIdx]]]` is the leaf itself.\n    //  - Leaves of each subtree are placed together, that is, the leaves of a dimCell are:\n    //    `this._cells.slice(dimCell.firstLeafLocator, dimCell.span[XY[this.dimIdx]])`\n    this._cells = [];\n    // Can be visited by `_levels[cell.level]` or `_levels[cell.id[1 - dimIdx] + _levels.length]`.\n    // Items are never be null/undefined after initialized.\n    this._levels = [];\n    this.dim = dim;\n    this.dimIdx = dim === 'x' ? 0 : 1;\n    this._model = dimModel;\n    this._uniqueValueGen = createUniqueValueGenerator(dim);\n    var dimModelData = dimModel.get('data', true);\n    if (dimModelData != null && !isArray(dimModelData)) {\n      if (process.env.NODE_ENV !== 'production') {\n        error(\"Illegal echarts option - matrix.\" + this.dim + \".data must be an array if specified.\");\n      }\n      dimModelData = [];\n    }\n    if (dimModelData) {\n      this._initByDimModelData(dimModelData);\n    } else {\n      this._initBySeriesData();\n    }\n  }\n  MatrixDim.prototype._initByDimModelData = function (dimModelData) {\n    var self = this;\n    var _cells = self._cells;\n    var _levels = self._levels;\n    var sameLocatorCellsLists = []; // Save for sorting.\n    var _cellCount = 0;\n    self._leavesCount = traverseInitCells(dimModelData, 0, 0);\n    postInitCells();\n    return;\n    function traverseInitCells(dimModelData, firstLeafLocator, level) {\n      var totalSpan = 0;\n      if (!dimModelData) {\n        return totalSpan;\n      }\n      each(dimModelData, function (option, optionIdx) {\n        var invalidOption = false;\n        var cellOption;\n        if (isString(option)) {\n          cellOption = {\n            value: option\n          };\n        } else if (isObject(option)) {\n          cellOption = option;\n          if (option.value != null && !isString(option.value)) {\n            invalidOption = true;\n            cellOption = {\n              value: null\n            };\n          }\n        } else {\n          cellOption = {\n            value: null\n          };\n          if (option != null) {\n            invalidOption = true;\n          }\n        }\n        if (invalidOption) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Illegal echarts option - matrix.\" + self.dim + \".data[\" + optionIdx + \"]\" + ' must be `string | {value: string}`.');\n          }\n        }\n        var cell = {\n          type: MatrixCellLayoutInfoType.nonLeaf,\n          ordinal: NaN,\n          level: level,\n          firstLeafLocator: firstLeafLocator,\n          id: new Point(),\n          span: setDimXYValue(new Point(), self.dimIdx, 1, 1),\n          option: cellOption,\n          xy: NaN,\n          wh: NaN,\n          dim: self,\n          rect: createNaNRectLike()\n        };\n        _cellCount++;\n        (sameLocatorCellsLists[firstLeafLocator] || (sameLocatorCellsLists[firstLeafLocator] = [])).push(cell);\n        if (!_levels[level]) {\n          // Create a level only if at least one cell exists.\n          _levels[level] = {\n            type: MatrixCellLayoutInfoType.level,\n            xy: NaN,\n            wh: NaN,\n            option: null,\n            id: new Point(),\n            dim: self\n          };\n        }\n        var childrenSpan = traverseInitCells(cellOption.children, firstLeafLocator, level + 1);\n        var subSpan = Math.max(1, childrenSpan);\n        cell.span[XY[self.dimIdx]] = subSpan;\n        totalSpan += subSpan;\n        firstLeafLocator += subSpan;\n      });\n      return totalSpan;\n    }\n    function postInitCells() {\n      // Sort to make sure the leaves are at the beginning, so that\n      // they can be used as the locator of body cells.\n      var categories = [];\n      while (_cells.length < _cellCount) {\n        for (var locator = 0; locator < sameLocatorCellsLists.length; locator++) {\n          var cell = sameLocatorCellsLists[locator].pop();\n          if (cell) {\n            cell.ordinal = categories.length;\n            var val = cell.option.value;\n            categories.push(val);\n            _cells.push(cell);\n            self._uniqueValueGen.calcDupBase(val);\n          }\n        }\n      }\n      self._uniqueValueGen.ensureValueUnique(categories, _cells);\n      var ordinalMeta = self._ordinalMeta = new OrdinalMeta({\n        categories: categories,\n        needCollect: false,\n        deduplication: false\n      });\n      self._scale = new Ordinal({\n        ordinalMeta: ordinalMeta\n      });\n      for (var idx = 0; idx < self._leavesCount; idx++) {\n        var leaf = self._cells[idx];\n        leaf.type = MatrixCellLayoutInfoType.leaf;\n        // Handle the tree level variation: enlarge the span of the leaves to reach the body cells.\n        leaf.span[XY[1 - self.dimIdx]] = self._levels.length - leaf.level;\n      }\n      self._initCellsId();\n      self._initLevelIdOptions();\n    }\n  };\n  MatrixDim.prototype._initBySeriesData = function () {\n    var self = this;\n    self._leavesCount = 0;\n    self._levels = [{\n      type: MatrixCellLayoutInfoType.level,\n      xy: NaN,\n      wh: NaN,\n      option: null,\n      id: new Point(),\n      dim: self\n    }];\n    self._initLevelIdOptions();\n    var ordinalMeta = self._ordinalMeta = new OrdinalMeta({\n      needCollect: true,\n      deduplication: true,\n      onCollect: function (value, ordinalNumber) {\n        var cell = self._cells[ordinalNumber] = {\n          type: MatrixCellLayoutInfoType.leaf,\n          ordinal: ordinalNumber,\n          level: 0,\n          firstLeafLocator: ordinalNumber,\n          id: new Point(),\n          span: setDimXYValue(new Point(), self.dimIdx, 1, 1),\n          // Theoretically `value` is from `dataset` or `series.data`, so it may be any type.\n          // Do not restrict this case for user's convenience, and here simply convert it to\n          // string for display.\n          option: {\n            value: value + ''\n          },\n          xy: NaN,\n          wh: NaN,\n          dim: self,\n          rect: createNaNRectLike()\n        };\n        self._leavesCount++;\n        self._setCellId(cell);\n      }\n    });\n    self._scale = new Ordinal({\n      ordinalMeta: ordinalMeta\n    });\n  };\n  MatrixDim.prototype._setCellId = function (cell) {\n    var levelsLen = this._levels.length;\n    var dimIdx = this.dimIdx;\n    setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);\n  };\n  MatrixDim.prototype._initCellsId = function () {\n    var levelsLen = this._levels.length;\n    var dimIdx = this.dimIdx;\n    each(this._cells, function (cell) {\n      setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);\n    });\n  };\n  MatrixDim.prototype._initLevelIdOptions = function () {\n    var levelsLen = this._levels.length;\n    var dimIdx = this.dimIdx;\n    var levelOptionList = this._model.get('levels', true);\n    levelOptionList = isArray(levelOptionList) ? levelOptionList : [];\n    each(this._levels, function (levelCfg, level) {\n      setDimXYValue(levelCfg.id, dimIdx, 0, level - levelsLen);\n      levelCfg.option = levelOptionList[level];\n    });\n  };\n  MatrixDim.prototype.shouldShow = function () {\n    return !!this._model.getShallow('show', true);\n  };\n  /**\n   * Iterate leaves (they are layout units) if dimIdx === this.dimIdx.\n   * Iterate levels if dimIdx !== this.dimIdx.\n   */\n  MatrixDim.prototype.resetLayoutIterator = function (it, dimIdx, startLocator, count) {\n    it = it || new ListIterator();\n    if (dimIdx === this.dimIdx) {\n      var len = this._leavesCount;\n      var startIdx = startLocator != null ? Math.max(0, startLocator) : 0;\n      count = count != null ? Math.min(count, len) : len;\n      it.reset(this._cells, startIdx, startIdx + count);\n    } else {\n      var len = this._levels.length;\n      // Corner locator is from `-this._levels.length` to `-1`.\n      var startIdx = startLocator != null ? Math.max(0, startLocator + len) : 0;\n      count = count != null ? Math.min(count, len) : len;\n      it.reset(this._levels, startIdx, startIdx + count);\n    }\n    return it;\n  };\n  MatrixDim.prototype.resetCellIterator = function (it) {\n    return (it || new ListIterator()).reset(this._cells, 0);\n  };\n  MatrixDim.prototype.resetLevelIterator = function (it) {\n    return (it || new ListIterator()).reset(this._levels, 0);\n  };\n  MatrixDim.prototype.getLayout = function (outRect, dimIdx, locator) {\n    var layout = this.getUnitLayoutInfo(dimIdx, locator);\n    outRect[XY[dimIdx]] = layout ? layout.xy : NaN;\n    outRect[WH[dimIdx]] = layout ? layout.wh : NaN;\n  };\n  /**\n   * Get leaf cell or get level info.\n   * Should be able to return null/undefined if not found on x or y, thus input `dimIdx` is needed.\n   */\n  MatrixDim.prototype.getUnitLayoutInfo = function (dimIdx, locator) {\n    return dimIdx === this.dimIdx ? locator < this._leavesCount ? this._cells[locator] : undefined : this._levels[locator + this._levels.length];\n  };\n  /**\n   * Get dimension cell by data, including leaves and non-leaves.\n   */\n  MatrixDim.prototype.getCell = function (value) {\n    var ordinal = this._scale.parse(value);\n    return eqNaN(ordinal) ? undefined : this._cells[ordinal];\n  };\n  /**\n   * Get leaf count or get level count.\n   */\n  MatrixDim.prototype.getLocatorCount = function (dimIdx) {\n    return dimIdx === this.dimIdx ? this._leavesCount : this._levels.length;\n  };\n  MatrixDim.prototype.getOrdinalMeta = function () {\n    return this._ordinalMeta;\n  };\n  return MatrixDim;\n}();\nexport { MatrixDim };\nfunction createUniqueValueGenerator(dim) {\n  var dimUpper = dim.toUpperCase();\n  var defaultValReg = new RegExp(\"^\" + dimUpper + \"([0-9]+)$\");\n  var dupBase = 0;\n  function calcDupBase(val) {\n    var matchResult;\n    if (val != null && (matchResult = val.match(defaultValReg))) {\n      dupBase = mathMax(dupBase, +matchResult[1] + 1);\n    }\n  }\n  function makeUniqueValue() {\n    return \"\" + dimUpper + dupBase++;\n  }\n  // Duplicated value is allowed, because the `matrix.x/y.data` can be a tree and it's reasonable\n  // that leaves in different subtrees has the same text. But only the first one is allowed to be\n  // queried by the text, and the other ones can only be queried by index.\n  // Additionally, `matrix.x/y.data: [null, null, ...]` is allowed.\n  function ensureValueUnique(categories, cells) {\n    // A simple way to deduplicate or handle illegal or not specified values to avoid unexpected behaviors.\n    // The tree structure should not be broken even if duplicated.\n    var cateMap = createHashMap();\n    for (var idx = 0; idx < categories.length; idx++) {\n      var value = categories[idx];\n      // value may be set to NullUndefined by users or if illegal.\n      if (value == null || cateMap.get(value) != null) {\n        // Still display the original option.value if duplicated, but loose the ability to query by text.\n        categories[idx] = value = makeUniqueValue();\n        cells[idx].option = defaults({\n          value: value\n        }, cells[idx].option);\n      }\n      cateMap.set(value, true);\n    }\n  }\n  return {\n    calcDupBase: calcDupBase,\n    ensureValueUnique: ensureValueUnique\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}