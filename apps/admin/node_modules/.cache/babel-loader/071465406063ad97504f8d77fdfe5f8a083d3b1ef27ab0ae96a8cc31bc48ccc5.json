{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { getLayoutRect } from '../../util/layout.js';\nimport { ListIterator } from '../../util/model.js';\nimport { eqNaN, isArray, retrieve2 } from 'zrender/lib/core/util.js';\nimport { WH, XY } from '../../util/graphic.js';\nimport Model from '../../model/Model.js';\nimport { mathMax, mathMin, parsePositionSizeOption } from '../../util/number.js';\nimport { createNaNRectLike, MatrixClampOption, MatrixCellLayoutInfoType, parseCoordRangeOption, resetXYLocatorRange, xyLocatorRangeToRectOneDim } from './matrixCoordHelper.js';\nimport { error } from '../../util/log.js';\nimport { injectCoordSysByOption, simpleCoordSysInjectionProvider } from '../../core/CoordinateSystem.js';\nvar Matrix = /** @class */function () {\n  function Matrix(matrixModel, ecModel, api) {\n    this.dimensions = Matrix.dimensions;\n    this.type = 'matrix';\n    this._model = matrixModel;\n    var models = this._dimModels = {\n      x: matrixModel.getDimensionModel('x'),\n      y: matrixModel.getDimensionModel('y')\n    };\n    this._dims = {\n      x: models.x.dim,\n      y: models.y.dim\n    };\n    this._resize(matrixModel, api);\n  }\n  /**\n   * @see fetchers in `model/referHelper.ts`,\n   * which is used to parse data in ordinal way.\n   * In most series only 'x' and 'y' is required,\n   * but some series, such as heatmap, can specify value.\n   */\n  Matrix.getDimensionsInfo = function () {\n    return [{\n      name: 'x',\n      type: 'ordinal'\n    }, {\n      name: 'y',\n      type: 'ordinal'\n    }, {\n      name: 'value'\n    }];\n  };\n  Matrix.create = function (ecModel, api) {\n    var matrixList = [];\n    ecModel.eachComponent('matrix', function (matrixModel) {\n      var matrix = new Matrix(matrixModel, ecModel, api);\n      matrixList.push(matrix);\n      matrixModel.coordinateSystem = matrix;\n    });\n    // Inject coordinate system\n    // PENDING: optimize to not to travel all components?\n    //  (collect relevant components in ecModel only when model update?)\n    ecModel.eachComponent(function (mainType, componentModel) {\n      injectCoordSysByOption({\n        targetModel: componentModel,\n        coordSysType: 'matrix',\n        coordSysProvider: simpleCoordSysInjectionProvider\n      });\n    });\n    return matrixList;\n  };\n  Matrix.prototype.getRect = function () {\n    return this._rect;\n  };\n  Matrix.prototype._resize = function (matrixModel, api) {\n    var dims = this._dims;\n    var dimModels = this._dimModels;\n    var rect = this._rect = getLayoutRect(matrixModel.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n    layOutUnitsOnDimension(dimModels, dims, rect, 0);\n    layOutUnitsOnDimension(dimModels, dims, rect, 1);\n    layOutDimCellsRestInfoByUnit(0, dims);\n    layOutDimCellsRestInfoByUnit(1, dims);\n    layOutBodyCornerCellMerge(this._model.getBody(), dims);\n    layOutBodyCornerCellMerge(this._model.getCorner(), dims);\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `[NaN, xxxresult]`/`[xxxresult, NaN]` or clamped boundary value if\n   *  `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - Alwasy return an numeric array, but never be null/undefined.\n   *  If it can not be located or invalid, return `[NaN, NaN]`.\n   */\n  Matrix.prototype.dataToPoint = function (data, opt, out) {\n    out = out || [];\n    this.dataToLayout(data, opt, _dtpOutDataToLayout);\n    out[0] = _dtpOutDataToLayout.rect.x + _dtpOutDataToLayout.rect.width / 2;\n    out[1] = _dtpOutDataToLayout.rect.y + _dtpOutDataToLayout.rect.height / 2;\n    return out;\n  };\n  /**\n   * @implement\n   * - The input is allowed to be `[NaN/null/undefined, xxx]`/`[xxx, NaN/null/undefined]`;\n   *  the return is `{x: NaN, width: NaN, y: xxxresulty, height: xxxresulth}`/\n   *  `{y: NaN, height: NaN, x: xxxresultx, width: xxxresultw}` or clamped boundary value\n   *  if `clamp` passed. This is for the usage that only get coord on single x or y.\n   * - The returned `out.rect` and `out.matrixXYLocatorRange` is always an object or an 2d-array,\n   *  but never be null/undefined. If it cannot be located or invalid, `NaN` is in their\n   *  corresponding number props.\n   * - Do not provide `out.contentRect`, because it's allowed to input non-leaf dimension x/y or\n   *  a range of x/y, which determines a rect covering multiple cells (even not merged), in which\n   *  case the padding and borderWidth can not be determined to make a contentRect. Therefore only\n   *  return `out.rect` in any case for consistency. The caller is responsible for adding space to\n   *  avoid covering cell borders, if necessary.\n   */\n  Matrix.prototype.dataToLayout = function (data, opt, out) {\n    var dims = this._dims;\n    out = out || {};\n    var outRect = out.rect = out.rect || {};\n    outRect.x = outRect.y = outRect.width = outRect.height = NaN;\n    var outLocRange = out.matrixXYLocatorRange = resetXYLocatorRange(out.matrixXYLocatorRange);\n    if (!isArray(data)) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Input data must be an array in `convertToLayout`, `convertToPixel`');\n      }\n      return out;\n    }\n    parseCoordRangeOption(outLocRange, null, data, dims, retrieve2(opt && opt.clamp, MatrixClampOption.none));\n    if (!opt || !opt.ignoreMergeCells) {\n      if (!opt || opt.clamp !== MatrixClampOption.corner) {\n        this._model.getBody().expandRangeByCellMerge(outLocRange);\n      }\n      if (!opt || opt.clamp !== MatrixClampOption.body) {\n        this._model.getCorner().expandRangeByCellMerge(outLocRange);\n      }\n    }\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 0);\n    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 1);\n    return out;\n  };\n  /**\n   * The returned locator pair can be the input of `dataToPoint` or `dataToLayout`.\n   *\n   * If point[0] is out of the matrix rect,\n   *  the out[0] is NaN;\n   * else if it is on the right of top-left corner of body,\n   *  the out[0] is the oridinal number (>= 0).\n   * else\n   *  out[0] is the locator for corner or header (<= 0).\n   *\n   * The same rule goes for point[1] and out[1].\n   *\n   * But point[0] and point[1] are calculated separately, i.e.,\n   * the reuslt can be `[1, NaN]` or `[NaN, 1]` if only one dimension is out of boundary.\n   *\n   * @implement\n   */\n  Matrix.prototype.pointToData = function (point, opt, out) {\n    var dims = this._dims;\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 0, dims, point, opt && opt.clamp);\n    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 1, dims, point, opt && opt.clamp);\n    out = out || [];\n    out[0] = out[1] = NaN;\n    if (_tmpCtxPointToData.y === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.x === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 0, dims);\n    } else if (_tmpCtxPointToData.x === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.y === CtxPointToDataAreaType.inBody) {\n      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out, 1, dims);\n    } else {\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 0, dims);\n      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out, 1, dims);\n    }\n    return out;\n  };\n  Matrix.prototype.convertToPixel = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToPoint(value, opt) : undefined;\n  };\n  Matrix.prototype.convertToLayout = function (ecModel, finder, value, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.dataToLayout(value, opt) : undefined;\n  };\n  Matrix.prototype.convertFromPixel = function (ecModel, finder, pixel, opt) {\n    var coordSys = getCoordSys(finder);\n    return coordSys === this ? coordSys.pointToData(pixel, opt) : undefined;\n  };\n  Matrix.prototype.containPoint = function (point) {\n    return this._rect.contain(point[0], point[1]);\n  };\n  Matrix.dimensions = ['x', 'y', 'value'];\n  return Matrix;\n}();\nvar _dtpOutDataToLayout = {\n  rect: createNaNRectLike()\n};\nvar _ptdLevelIt = new ListIterator();\nvar _ptdDimCellIt = new ListIterator();\nfunction layOutUnitsOnDimension(dimModels, dims, matrixRect, dimIdx) {\n  var otherDimIdx = 1 - dimIdx;\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[otherDimIdx]];\n  // Notice: If matrix.x/y.show is false, still lay out, to ensure the\n  // consistent return of `dataToLayout`.\n  var otherDimShow = otherDim.shouldShow();\n  // Reset\n  for (var it_1 = thisDim.resetCellIterator(); it_1.next();) {\n    it_1.item.wh = it_1.item.xy = NaN;\n  }\n  for (var it_2 = otherDim.resetLayoutIterator(null, dimIdx); it_2.next();) {\n    it_2.item.wh = it_2.item.xy = NaN;\n  }\n  // Set specified size from option.\n  var restSize = matrixRect[WH[dimIdx]];\n  var restCellsCount = thisDim.getLocatorCount(dimIdx) + otherDim.getLocatorCount(dimIdx);\n  var tmpLevelModel = new Model();\n  for (var it_3 = otherDim.resetLevelIterator(); it_3.next();) {\n    // Consider `matrix.x.levelSize` and `matrix.x.levels[i].levelSize`.\n    tmpLevelModel.option = it_3.item.option;\n    tmpLevelModel.parentModel = dimModels[XY[otherDimIdx]];\n    layOutSpecified(it_3.item, otherDimShow ? tmpLevelModel.get('levelSize') : 0);\n  }\n  var tmpCellModel = new Model();\n  for (var it_4 = thisDim.resetCellIterator(); it_4.next();) {\n    // Only leaf support size specification, to avoid unnecessary complexity.\n    if (it_4.item.type === MatrixCellLayoutInfoType.leaf) {\n      tmpCellModel.option = it_4.item.option;\n      tmpCellModel.parentModel = undefined;\n      layOutSpecified(it_4.item, tmpCellModel.get('size'));\n    }\n  }\n  function layOutSpecified(item, sizeOption) {\n    var size = parseSizeOption(sizeOption, dimIdx, matrixRect);\n    if (!eqNaN(size)) {\n      item.wh = confineSize(size, restSize);\n      restSize = confineSize(restSize - item.wh);\n      restCellsCount--;\n    }\n  }\n  // Set all sizes and positions to levels and leaf cells of which size is unspecified.\n  // Contents lay out based on matrix, rather than inverse; therefore do not support\n  // calculating size based on content, but allocate equally.\n  var computedCellWH = restCellsCount ? restSize / restCellsCount : 0;\n  // If all size specified, but some space remain (may also caused by matrix.x/y.show: false)\n  // do not align to the big most edge.\n  var notAlignToBigmost = !restCellsCount && restSize >= 1; // `1` for cumulative precision error.\n  var currXY = matrixRect[XY[dimIdx]];\n  var maxLocator = thisDim.getLocatorCount(dimIdx) - 1;\n  var it = new ListIterator();\n  // Lay out levels of the perpendicular dim.\n  for (otherDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  for (thisDim.resetLayoutIterator(it, dimIdx); it.next();) {\n    layOutUnspecified(it.item);\n  }\n  function layOutUnspecified(item) {\n    if (eqNaN(item.wh)) {\n      item.wh = computedCellWH;\n    }\n    item.xy = currXY;\n    if (item.id[XY[dimIdx]] === maxLocator && !notAlignToBigmost) {\n      // Align to the rightmost border, consider cumulative precision error.\n      item.wh = matrixRect[XY[dimIdx]] + matrixRect[WH[dimIdx]] - item.xy;\n    }\n    currXY += item.wh;\n  }\n}\nfunction layOutDimCellsRestInfoByUnit(dimIdx, dims) {\n  // Finally save layout info based on the unit leaves and levels.\n  for (var it_5 = dims[XY[dimIdx]].resetCellIterator(); it_5.next();) {\n    var dimCell = it_5.item;\n    layOutRectOneDimBasedOnUnit(dimCell.rect, dimIdx, dimCell.id, dimCell.span, dims);\n    // Consider level varitation on tree leaves, should extend the size to touch matrix body\n    // to avoid weird appearance.\n    layOutRectOneDimBasedOnUnit(dimCell.rect, 1 - dimIdx, dimCell.id, dimCell.span, dims);\n    if (dimCell.type === MatrixCellLayoutInfoType.nonLeaf) {\n      // `xy` and `wh` need to be saved in non-leaf since it supports locating by non-leaf\n      // in `dataToPoint` or `dataToLayout`.\n      dimCell.xy = dimCell.rect[XY[dimIdx]];\n      dimCell.wh = dimCell.rect[WH[dimIdx]];\n    }\n  }\n}\nfunction layOutBodyCornerCellMerge(bodyOrCorner, dims) {\n  bodyOrCorner.travelExistingCells(function (cell) {\n    var computedSpan = cell.span;\n    if (computedSpan) {\n      var layoutRect = cell.spanRect;\n      var id = cell.id;\n      layOutRectOneDimBasedOnUnit(layoutRect, 0, id, computedSpan, dims);\n      layOutRectOneDimBasedOnUnit(layoutRect, 1, id, computedSpan, dims);\n    }\n  });\n}\n// Save to rect for rendering.\nfunction layOutRectOneDimBasedOnUnit(outRect, dimIdx, id, span, dims) {\n  outRect[WH[dimIdx]] = 0;\n  var locator = id[XY[dimIdx]];\n  var dim = locator < 0 ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  var layoutUnit = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]]);\n  outRect[XY[dimIdx]] = layoutUnit.xy;\n  outRect[WH[dimIdx]] = layoutUnit.wh;\n  if (span[XY[dimIdx]] > 1) {\n    var layoutUnit2 = dim.getUnitLayoutInfo(dimIdx, id[XY[dimIdx]] + span[XY[dimIdx]] - 1);\n    // Be careful the cumulative error - cell must be aligned.\n    outRect[WH[dimIdx]] = layoutUnit2.xy + layoutUnit2.wh - layoutUnit.xy;\n  }\n}\n/**\n * Return NaN if not defined or invalid.\n */\nfunction parseSizeOption(sizeOption, dimIdx, matrixRect) {\n  var sizeNum = parsePositionSizeOption(sizeOption, matrixRect[WH[dimIdx]]);\n  return confineSize(sizeNum, matrixRect[WH[dimIdx]]);\n}\nfunction confineSize(sizeNum, sizeLimit) {\n  return Math.max(Math.min(sizeNum, retrieve2(sizeLimit, Infinity)), 0);\n}\nfunction getCoordSys(finder) {\n  var matrixModel = finder.matrixModel;\n  var seriesModel = finder.seriesModel;\n  var coordSys = matrixModel ? matrixModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;\n  return coordSys;\n}\nvar CtxPointToDataAreaType = {\n  inBody: 1,\n  inCorner: 2,\n  outside: 3\n};\n// For handy performance optimization in pointToData.\nvar _tmpCtxPointToData = {\n  x: null,\n  y: null,\n  point: []\n};\nfunction pointToDataOneDimPrepareCtx(ctx, dimIdx, dims, point, clamp) {\n  var thisDim = dims[XY[dimIdx]];\n  var otherDim = dims[XY[1 - dimIdx]];\n  // Notice: considered cases: `matrix.x/y.show: false`, `matrix.x/y.data` is empty.\n  // In this cases the `layout.xy` is on the edge and `layout.wh` is `0`; they still can be\n  // use to calculate clampping.\n  var bodyMaxUnit = thisDim.getUnitLayoutInfo(dimIdx, thisDim.getLocatorCount(dimIdx) - 1);\n  var body0Unit = thisDim.getUnitLayoutInfo(dimIdx, 0);\n  var cornerMinUnit = otherDim.getUnitLayoutInfo(dimIdx, -otherDim.getLocatorCount(dimIdx));\n  var cornerMinus1Unit = otherDim.shouldShow() ? otherDim.getUnitLayoutInfo(dimIdx, -1) : null;\n  var coord = ctx.point[dimIdx] = point[dimIdx]; // Transfer the oridinal coord.\n  if (!body0Unit && !cornerMinus1Unit) {\n    ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    return;\n  }\n  if (clamp === MatrixClampOption.body) {\n    if (body0Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inBody;\n      coord = mathMin(bodyMaxUnit.xy + bodyMaxUnit.wh, mathMax(body0Unit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to body, the result must not be in header.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  } else if (clamp === MatrixClampOption.corner) {\n    if (cornerMinus1Unit) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.inCorner;\n      coord = mathMin(cornerMinus1Unit.xy + cornerMinus1Unit.wh, mathMax(cornerMinUnit.xy, coord));\n      ctx.point[dimIdx] = coord;\n    } else {\n      // If clamp to corner, the result must not be in body.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n    }\n    return;\n  }\n  var pxLoc0 = body0Unit ? body0Unit.xy : cornerMinus1Unit ? cornerMinus1Unit.xy + cornerMinus1Unit.wh : NaN;\n  var pxMin = cornerMinUnit ? cornerMinUnit.xy : pxLoc0;\n  var pxMax = bodyMaxUnit ? bodyMaxUnit.xy + bodyMaxUnit.wh : pxLoc0;\n  if (coord < pxMin) {\n    if (!clamp) {\n      // Quick pass for later calc, since mouse event on any place will enter this method if use `pointToData`.\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMin;\n  } else if (coord > pxMax) {\n    if (!clamp) {\n      ctx[XY[dimIdx]] = CtxPointToDataAreaType.outside;\n      return;\n    }\n    coord = pxMax;\n  }\n  ctx.point[dimIdx] = coord; // Save the updated coord.\n  ctx[XY[dimIdx]] = pxLoc0 <= coord && coord <= pxMax ? CtxPointToDataAreaType.inBody : pxMin <= coord && coord <= pxLoc0 ? CtxPointToDataAreaType.inCorner : CtxPointToDataAreaType.outside;\n  // Every props in ctx must be set in every branch of this method.\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataOnlyHeaderFillOut(ctx, partialOut, dimIdx, dims) {\n  var otherDimIdx = 1 - dimIdx;\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  for (dims[XY[dimIdx]].resetCellIterator(_ptdDimCellIt); _ptdDimCellIt.next();) {\n    var cell = _ptdDimCellIt.item;\n    if (isCoordInRect(ctx.point[dimIdx], cell.rect, dimIdx) && isCoordInRect(ctx.point[otherDimIdx], cell.rect, otherDimIdx)) {\n      // non-leaves are also allowed to be located.\n      // If the point is in x or y dimension cell area, should check both x and y coord to\n      // determine a cell; in this way a non-leaf cell can be determined.\n      partialOut[dimIdx] = cell.ordinal;\n      partialOut[otherDimIdx] = cell.id[XY[otherDimIdx]];\n      return;\n    }\n  }\n}\n// Assume partialOut has been set to NaN outside.\n// This method may fill out[0] and out[1] in one call.\nfunction pointToDataBodyCornerFillOut(ctx, partialOut, dimIdx, dims) {\n  if (ctx[XY[dimIdx]] === CtxPointToDataAreaType.outside) {\n    return;\n  }\n  var dim = ctx[XY[dimIdx]] === CtxPointToDataAreaType.inCorner ? dims[XY[1 - dimIdx]] : dims[XY[dimIdx]];\n  for (dim.resetLayoutIterator(_ptdLevelIt, dimIdx); _ptdLevelIt.next();) {\n    if (isCoordInLayoutInfo(ctx.point[dimIdx], _ptdLevelIt.item)) {\n      partialOut[dimIdx] = _ptdLevelIt.item.id[XY[dimIdx]];\n      return;\n    }\n  }\n}\nfunction isCoordInLayoutInfo(coord, cell) {\n  return cell.xy <= coord && coord <= cell.xy + cell.wh;\n}\nfunction isCoordInRect(coord, rect, dimIdx) {\n  return rect[XY[dimIdx]] <= coord && coord <= rect[XY[dimIdx]] + rect[WH[dimIdx]];\n}\nexport default Matrix;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}