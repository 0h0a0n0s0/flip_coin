{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport Axis2D from '../coord/cartesian/Axis2D.js';\nimport { makeInner } from './model.js';\nexport function needFixJitter(seriesModel, axis) {\n  var coordinateSystem = seriesModel.coordinateSystem;\n  var coordType = coordinateSystem && coordinateSystem.type;\n  var baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();\n  var scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;\n  var seriesValid = coordType === 'cartesian2d' && scaleType === 'ordinal' || coordType === 'single';\n  var axisValid = axis.model.get('jitter') > 0;\n  return seriesValid && axisValid;\n}\nvar inner = makeInner();\n/**\n * Fix jitter for overlapping data points.\n *\n * @param fixedAxis The axis whose coord doesn't change with jitter.\n * @param fixedCoord The coord of fixedAxis.\n * @param floatCoord The coord of the other axis, which should be changed with jittering.\n * @param radius The radius of the data point, considering the symbol is a circle.\n * @returns updated floatCoord.\n */\nexport function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {\n  if (fixedAxis instanceof Axis2D) {\n    var scaleType = fixedAxis.scale.type;\n    if (scaleType !== 'category' && scaleType !== 'ordinal') {\n      return floatCoord;\n    }\n  }\n  var axisModel = fixedAxis.model;\n  var jitter = axisModel.get('jitter');\n  var jitterOverlap = axisModel.get('jitterOverlap');\n  var jitterMargin = axisModel.get('jitterMargin') || 0;\n  // Get band width to limit jitter range\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  if (jitter > 0) {\n    if (jitterOverlap) {\n      return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n    } else {\n      return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);\n    }\n  }\n  return floatCoord;\n}\nfunction fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {\n  // Don't clamp single axis\n  if (bandWidth === null) {\n    return floatCoord + (Math.random() - 0.5) * jitter;\n  }\n  var maxJitter = bandWidth - radius * 2;\n  var actualJitter = Math.min(Math.max(0, jitter), maxJitter);\n  return floatCoord + (Math.random() - 0.5) * actualJitter;\n}\nfunction fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {\n  var store = inner(fixedAxis);\n  if (!store.items) {\n    store.items = [];\n  }\n  var items = store.items;\n  // Try both positive and negative directions, choose the one with smaller movement\n  var overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);\n  var overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);\n  var minFloat = Math.abs(overlapA - floatCoord) < Math.abs(overlapB - floatCoord) ? overlapA : overlapB;\n  // Clamp only category axis\n  var bandWidth = fixedAxis.scale.type === 'ordinal' ? fixedAxis.getBandWidth() : null;\n  var distance = Math.abs(minFloat - floatCoord);\n  if (distance > jitter / 2 || bandWidth && distance > bandWidth / 2 - radius) {\n    // If the new item is moved too far, then give up.\n    // Fall back to random jitter.\n    return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);\n  }\n  // Add new point to array\n  items.push({\n    fixedCoord: fixedCoord,\n    floatCoord: minFloat,\n    r: radius\n  });\n  return minFloat;\n}\nfunction placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {\n  var y = floatCoord;\n  // Check all existing items for overlap and find the maximum adjustment needed\n  for (var i = 0; i < items.length; i++) {\n    var item = items[i];\n    var dx = fixedCoord - item.fixedCoord;\n    var dy = y - item.floatCoord;\n    var d2 = dx * dx + dy * dy;\n    var r = radius + item.r + margin;\n    if (d2 < r * r) {\n      // Has overlap, calculate required adjustment\n      var requiredY = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;\n      // Check if this adjustment would move too far\n      if (Math.abs(requiredY - floatCoord) > jitter / 2) {\n        return Number.MAX_VALUE; // Give up\n      }\n      // Update y only when it's larger to the center\n      if (direction === 1 && requiredY > y || direction === -1 && requiredY < y) {\n        y = requiredY;\n        // Loop from the start again\n        i = -1; // Reset index to recheck all items\n        continue; // Recalculate with the new y position\n      }\n    }\n  }\n  return y;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}