{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { extend, isString } from 'zrender/lib/core/util.js';\nimport * as graphic from '../../util/graphic.js';\nimport { getSectorCornerRadius } from '../helper/sectorHelper.js';\nimport { saveOldStyle } from '../../animation/basicTransition.js';\nimport { setStatesStylesFromModel, toggleHoverEmphasis } from '../../util/states.js';\nimport { getECData } from '../../util/innerStore.js';\nvar ChordPathShape = /** @class */function () {\n  function ChordPathShape() {\n    // Souce node, two points forming an arc\n    this.s1 = [0, 0];\n    this.s2 = [0, 0];\n    this.sStartAngle = 0;\n    this.sEndAngle = 0;\n    // Target node, two points forming an arc\n    this.t1 = [0, 0];\n    this.t2 = [0, 0];\n    this.tStartAngle = 0;\n    this.tEndAngle = 0;\n    this.cx = 0;\n    this.cy = 0;\n    // series.r0 of ChordSeries\n    this.r = 0;\n    this.clockwise = true;\n  }\n  return ChordPathShape;\n}();\nexport { ChordPathShape };\nvar ChordEdge = /** @class */function (_super) {\n  __extends(ChordEdge, _super);\n  function ChordEdge(nodeData, edgeData, edgeIdx, startAngle) {\n    var _this = _super.call(this) || this;\n    getECData(_this).dataType = 'edge';\n    _this.updateData(nodeData, edgeData, edgeIdx, startAngle, true);\n    return _this;\n  }\n  ChordEdge.prototype.buildPath = function (ctx, shape) {\n    // Start from n11\n    ctx.moveTo(shape.s1[0], shape.s1[1]);\n    var ratio = 0.7;\n    var clockwise = shape.clockwise;\n    // Draw the arc from n11 to n12\n    ctx.arc(shape.cx, shape.cy, shape.r, shape.sStartAngle, shape.sEndAngle, !clockwise);\n    // Bezier curve to cp1 and then to n21\n    ctx.bezierCurveTo((shape.cx - shape.s2[0]) * ratio + shape.s2[0], (shape.cy - shape.s2[1]) * ratio + shape.s2[1], (shape.cx - shape.t1[0]) * ratio + shape.t1[0], (shape.cy - shape.t1[1]) * ratio + shape.t1[1], shape.t1[0], shape.t1[1]);\n    // Draw the arc from n21 to n22\n    ctx.arc(shape.cx, shape.cy, shape.r, shape.tStartAngle, shape.tEndAngle, !clockwise);\n    // Bezier curve back to cp2 and then to n11\n    ctx.bezierCurveTo((shape.cx - shape.t2[0]) * ratio + shape.t2[0], (shape.cy - shape.t2[1]) * ratio + shape.t2[1], (shape.cx - shape.s1[0]) * ratio + shape.s1[0], (shape.cy - shape.s1[1]) * ratio + shape.s1[1], shape.s1[0], shape.s1[1]);\n    ctx.closePath();\n  };\n  ChordEdge.prototype.updateData = function (nodeData, edgeData, edgeIdx, startAngle, firstCreate) {\n    var seriesModel = nodeData.hostModel;\n    var edge = edgeData.graph.getEdgeByIndex(edgeIdx);\n    var layout = edge.getLayout();\n    var itemModel = edge.node1.getModel();\n    var edgeModel = edgeData.getItemModel(edge.dataIndex);\n    var lineStyle = edgeModel.getModel('lineStyle');\n    var emphasisModel = edgeModel.getModel('emphasis');\n    var focus = emphasisModel.get('focus');\n    var shape = extend(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout, true), layout);\n    var el = this;\n    // Ignore NaN data.\n    if (isNaN(shape.sStartAngle) || isNaN(shape.tStartAngle)) {\n      // Use NaN shape to avoid drawing shape.\n      el.setShape(shape);\n      return;\n    }\n    if (firstCreate) {\n      el.setShape(shape);\n      applyEdgeFill(el, edge, nodeData, lineStyle);\n    } else {\n      saveOldStyle(el);\n      applyEdgeFill(el, edge, nodeData, lineStyle);\n      graphic.updateProps(el, {\n        shape: shape\n      }, seriesModel, edgeIdx);\n    }\n    toggleHoverEmphasis(this, focus === 'adjacency' ? edge.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'));\n    setStatesStylesFromModel(el, edgeModel, 'lineStyle');\n    edgeData.setItemGraphicEl(edge.dataIndex, el);\n  };\n  return ChordEdge;\n}(graphic.Path);\nexport { ChordEdge };\nfunction applyEdgeFill(edgeShape, edge, nodeData, lineStyleModel) {\n  var node1 = edge.node1;\n  var node2 = edge.node2;\n  var edgeStyle = edgeShape.style;\n  edgeShape.setStyle(lineStyleModel.getLineStyle());\n  var color = lineStyleModel.get('color');\n  switch (color) {\n    case 'source':\n      // TODO: use visual and node1.getVisual('color');\n      edgeStyle.fill = nodeData.getItemVisual(node1.dataIndex, 'style').fill;\n      edgeStyle.decal = node1.getVisual('style').decal;\n      break;\n    case 'target':\n      edgeStyle.fill = nodeData.getItemVisual(node2.dataIndex, 'style').fill;\n      edgeStyle.decal = node2.getVisual('style').decal;\n      break;\n    case 'gradient':\n      var sourceColor = nodeData.getItemVisual(node1.dataIndex, 'style').fill;\n      var targetColor = nodeData.getItemVisual(node2.dataIndex, 'style').fill;\n      if (isString(sourceColor) && isString(targetColor)) {\n        // Gradient direction is perpendicular to the mid-angles\n        // of source and target nodes.\n        var shape = edgeShape.shape;\n        var sMidX = (shape.s1[0] + shape.s2[0]) / 2;\n        var sMidY = (shape.s1[1] + shape.s2[1]) / 2;\n        var tMidX = (shape.t1[0] + shape.t2[0]) / 2;\n        var tMidY = (shape.t1[1] + shape.t2[1]) / 2;\n        edgeStyle.fill = new graphic.LinearGradient(sMidX, sMidY, tMidX, tMidY, [{\n          offset: 0,\n          color: sourceColor\n        }, {\n          offset: 1,\n          color: targetColor\n        }], true);\n      }\n      break;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}