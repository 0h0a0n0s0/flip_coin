{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport ComponentView from '../../view/Component.js';\nimport Model from '../../model/Model.js';\nimport BoundingRect from 'zrender/lib/core/BoundingRect.js';\nimport * as vectorUtil from 'zrender/lib/core/vector.js';\nimport { subPixelOptimize } from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { Rect, Line, XY, setTooltipConfig, expandOrShrinkRect } from '../../util/graphic.js';\nimport { clearTmpModel, ListIterator } from '../../util/model.js';\nimport { clone, retrieve2 } from 'zrender/lib/core/util.js';\nimport { invert } from 'zrender/lib/core/matrix.js';\nimport { setLabelStyle } from '../../label/labelStyle.js';\nvar round = Math.round;\nvar Z2_BACKGROUND = 0;\nvar Z2_OUTER_BORDER = 99;\nvar Z2_BODY_CORNER_CELL_DEFAULT = {\n  normal: 25,\n  special: 100\n};\nvar Z2_DIMENSION_CELL_DEFAULT = {\n  normal: 50,\n  special: 125\n};\nvar MatrixView = /** @class */function (_super) {\n  __extends(MatrixView, _super);\n  function MatrixView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = MatrixView.type;\n    return _this;\n  }\n  MatrixView.prototype.render = function (matrixModel, ecModel) {\n    this.group.removeAll();\n    var group = this.group;\n    var coordSys = matrixModel.coordinateSystem;\n    var rect = coordSys.getRect();\n    var xDimModel = matrixModel.getDimensionModel('x');\n    var yDimModel = matrixModel.getDimensionModel('y');\n    var xDim = xDimModel.dim;\n    var yDim = yDimModel.dim;\n    // PENDING:\n    //  reuse the existing text and rect elements for performance?\n    renderDimensionCells(group, matrixModel, ecModel);\n    createBodyAndCorner(group, matrixModel, xDim, yDim, ecModel);\n    var borderZ2Option = matrixModel.getShallow('borderZ2', true);\n    var outerBorderZ2 = retrieve2(borderZ2Option, Z2_OUTER_BORDER);\n    var dividerLineZ2 = outerBorderZ2 - 1;\n    // Outer border and overall background. Use separate elements because of z-order:\n    // The overall background should appear below any other elements.\n    // But in most cases, the outer border and the divider line should be above the normal cell borders -\n    // especially when cell borders have different colors. But users may highlight some specific cells by\n    // overstirking their border, in which case it should be above the outer border.\n    var bgStyle = matrixModel.getModel('backgroundStyle').getItemStyle(['borderWidth']);\n    bgStyle.lineWidth = 0;\n    var borderStyle = matrixModel.getModel('backgroundStyle').getItemStyle(['color', 'decal', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']);\n    borderStyle.fill = 'none';\n    var bgRect = createMatrixRect(rect.clone(), bgStyle, Z2_BACKGROUND);\n    var borderRect = createMatrixRect(rect.clone(), borderStyle, outerBorderZ2);\n    bgRect.silent = true;\n    borderRect.silent = true;\n    group.add(bgRect);\n    group.add(borderRect);\n    // Header split line.\n    var xDimCell0 = xDim.getUnitLayoutInfo(0, 0);\n    var yDimCell0 = yDim.getUnitLayoutInfo(1, 0);\n    if (xDimCell0 && yDimCell0) {\n      if (xDim.shouldShow()) {\n        group.add(createMatrixLine({\n          x1: rect.x,\n          y1: yDimCell0.xy,\n          x2: rect.x + rect.width,\n          y2: yDimCell0.xy\n        }, xDimModel.getModel('dividerLineStyle').getLineStyle(), dividerLineZ2));\n      }\n      if (yDim.shouldShow()) {\n        group.add(createMatrixLine({\n          x1: xDimCell0.xy,\n          y1: rect.y,\n          x2: xDimCell0.xy,\n          y2: rect.y + rect.height\n        }, yDimModel.getModel('dividerLineStyle').getLineStyle(), dividerLineZ2));\n      }\n    }\n  };\n  MatrixView.type = 'matrix';\n  return MatrixView;\n}(ComponentView);\nfunction renderDimensionCells(group, matrixModel, ecModel) {\n  renderOnDimension(0);\n  renderOnDimension(1);\n  function renderOnDimension(dimIdx) {\n    var thisDimModel = matrixModel.getDimensionModel(XY[dimIdx]);\n    var thisDim = thisDimModel.dim;\n    if (!thisDim.shouldShow()) {\n      return;\n    }\n    var thisDimBgStyleModel = thisDimModel.getModel('itemStyle');\n    var thisDimLabelModel = thisDimModel.getModel('label');\n    var tooltipOption = matrixModel.getShallow('tooltip', true);\n    var xyLocator = [];\n    for (var it_1 = thisDim.resetCellIterator(); it_1.next();) {\n      var dimCell = it_1.item;\n      var shape = {};\n      BoundingRect.copy(shape, dimCell.rect);\n      vectorUtil.set(xyLocator, dimCell.id.x, dimCell.id.y);\n      createMatrixCell(xyLocator, matrixModel, group, ecModel, dimCell.option, thisDimBgStyleModel, thisDimLabelModel, thisDimModel, shape, dimCell.option.value, Z2_DIMENSION_CELL_DEFAULT, tooltipOption);\n    }\n  }\n}\nfunction createBodyAndCorner(group, matrixModel, xDim, yDim, ecModel) {\n  createBodyOrCornerCells('body', matrixModel.getBody(), xDim, yDim);\n  if (xDim.shouldShow() && yDim.shouldShow()) {\n    createBodyOrCornerCells('corner', matrixModel.getCorner(), yDim, xDim);\n  }\n  function createBodyOrCornerCells(bodyCornerOptionRoot, bodyOrCorner, dimForCoordX,\n  // Can be `matrix.y` (transposed) for corners.\n  dimForCoordY) {\n    // Prevent inheriting from ancestor.\n    var parentCellModel = new Model(matrixModel.getShallow(bodyCornerOptionRoot, true));\n    var parentItemStyleModel = parentCellModel.getModel('itemStyle');\n    var parentLabelModel = parentCellModel.getModel('label');\n    var itx = new ListIterator();\n    var ity = new ListIterator();\n    var xyLocator = [];\n    var tooltipOption = matrixModel.getShallow('tooltip', true);\n    for (dimForCoordY.resetLayoutIterator(ity, 1); ity.next();) {\n      for (dimForCoordX.resetLayoutIterator(itx, 0); itx.next();) {\n        var xLayout = itx.item;\n        var yLayout = ity.item;\n        vectorUtil.set(xyLocator, xLayout.id.x, yLayout.id.y);\n        var bodyCornerCell = bodyOrCorner.getCell(xyLocator);\n        // If in span of an other body or corner cell, never render it.\n        if (bodyCornerCell && bodyCornerCell.inSpanOf && bodyCornerCell.inSpanOf !== bodyCornerCell) {\n          continue;\n        }\n        var shape = {};\n        if (bodyCornerCell && bodyCornerCell.span) {\n          BoundingRect.copy(shape, bodyCornerCell.spanRect);\n        } else {\n          xLayout.dim.getLayout(shape, 0, xyLocator[0]);\n          yLayout.dim.getLayout(shape, 1, xyLocator[1]);\n        }\n        var bodyCornerCellOption = bodyCornerCell ? bodyCornerCell.option : null;\n        createMatrixCell(xyLocator, matrixModel, group, ecModel, bodyCornerCellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, bodyCornerCellOption ? bodyCornerCellOption.value : null, Z2_BODY_CORNER_CELL_DEFAULT, tooltipOption);\n      }\n    }\n  } // End of createBodyOrCornerCells\n}\nfunction createMatrixCell(xyLocator, matrixModel, group, ecModel, cellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, textValue, zrCellDefault, tooltipOption) {\n  var _a;\n  // Do not use getModel for handy performance optimization.\n  _tmpCellItemStyleModel.option = cellOption ? cellOption.itemStyle : null;\n  _tmpCellItemStyleModel.parentModel = parentItemStyleModel;\n  _tmpCellModel.option = cellOption;\n  _tmpCellModel.parentModel = parentCellModel;\n  // Use different z2 because special border may be defined in itemStyle.\n  var z2 = retrieve2(_tmpCellModel.getShallow('z2'), cellOption && cellOption.itemStyle ? zrCellDefault.special : zrCellDefault.normal);\n  var tooltipOptionShow = tooltipOption && tooltipOption.show;\n  var cellRect = createMatrixRect(shape, _tmpCellItemStyleModel.getItemStyle(), z2);\n  group.add(cellRect);\n  var cursorOption = _tmpCellModel.get('cursor');\n  if (cursorOption != null) {\n    cellRect.attr('cursor', cursorOption);\n  }\n  var cellText;\n  if (textValue != null) {\n    var text = textValue + '';\n    _tmpCellLabelModel.option = cellOption ? cellOption.label : null;\n    _tmpCellLabelModel.parentModel = parentLabelModel;\n    // This is to accept `option.textStyle` as the default.\n    _tmpCellLabelModel.ecModel = ecModel;\n    setLabelStyle(cellRect,\n    // Currently do not support other states (`emphasis`, `select`, `blur`)\n    {\n      normal: _tmpCellLabelModel\n    }, {\n      defaultText: text,\n      autoOverflowArea: true,\n      // By default based on boundingRect. But boundingRect contains borderWidth,\n      // and borderWidth is half outside the cell. Thus specific `layoutRect` explicitly.\n      layoutRect: clone(cellRect.shape)\n    });\n    cellText = cellRect.getTextContent();\n    if (cellText) {\n      cellText.z2 = z2 + 1;\n      var style = cellText.style;\n      if (style && style.overflow && style.overflow !== 'none' && style.lineOverflow) {\n        // `overflow: 'break'/'breakAll'/'truncate'` does not guarantee prevention of overflow\n        // when space is insufficient. Use a `clipPath` in such case.\n        var clipShape = {};\n        BoundingRect.copy(clipShape, shape);\n        // `lineWidth` is half outside half inside the bounding rect.\n        expandOrShrinkRect(clipShape, (((_a = cellRect.style) === null || _a === void 0 ? void 0 : _a.lineWidth) || 0) / 2, true, true);\n        cellRect.updateInnerText();\n        cellText.getLocalTransform(_tmpInnerTextTrans);\n        invert(_tmpInnerTextTrans, _tmpInnerTextTrans);\n        BoundingRect.applyTransform(clipShape, clipShape, _tmpInnerTextTrans);\n        cellText.setClipPath(new Rect({\n          shape: clipShape\n        }));\n      }\n    }\n    setTooltipConfig({\n      el: cellRect,\n      componentModel: matrixModel,\n      itemName: text,\n      itemTooltipOption: tooltipOption,\n      formatterParamsExtra: {\n        xyLocator: xyLocator.slice()\n      }\n    });\n  }\n  // Set silent\n  if (cellText) {\n    var labelSilent = _tmpCellLabelModel.get('silent');\n    // auto, tooltip of text cells need silient: false, but non-text cells\n    // do not need a special cursor in most cases.\n    if (labelSilent == null) {\n      labelSilent = !tooltipOptionShow;\n    }\n    cellText.silent = labelSilent;\n    cellText.ignoreHostSilent = true;\n  }\n  var rectSilent = _tmpCellModel.get('silent');\n  if (rectSilent == null) {\n    rectSilent =\n    // If no background color in cell, set `rect.silent: false` will cause that only\n    // the border response to mouse hovering, which is probably weird.\n    !cellRect.style || cellRect.style.fill === 'none' || !cellRect.style.fill;\n  }\n  cellRect.silent = rectSilent;\n  clearTmpModel(_tmpCellModel);\n  clearTmpModel(_tmpCellItemStyleModel);\n  clearTmpModel(_tmpCellLabelModel);\n}\nvar _tmpCellModel = new Model();\nvar _tmpCellItemStyleModel = new Model();\nvar _tmpCellLabelModel = new Model();\nvar _tmpInnerTextTrans = [];\n// FIXME: move all of the subpixel process to Matrix.ts resize, otherwise the result of\n// `dataToLayout` is not consistent with this rendering, and the caller (like heatmap) can\n// not precisely align with the matrix border.\nfunction createMatrixRect(shape, style, z2) {\n  // Currently `subPixelOptimizeRect` can not be used here because it will break rect alignment.\n  // Optimize line and rect with the same direction.\n  var lineWidth = style.lineWidth;\n  if (lineWidth) {\n    var x2Original = shape.x + shape.width;\n    var y2Original = shape.y + shape.height;\n    shape.x = subPixelOptimize(shape.x, lineWidth, true);\n    shape.y = subPixelOptimize(shape.y, lineWidth, true);\n    shape.width = subPixelOptimize(x2Original, lineWidth, true) - shape.x;\n    shape.height = subPixelOptimize(y2Original, lineWidth, true) - shape.y;\n  }\n  return new Rect({\n    shape: shape,\n    style: style,\n    z2: z2\n  });\n}\nfunction createMatrixLine(shape, style, z2) {\n  var lineWidth = style.lineWidth;\n  if (lineWidth) {\n    if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\n      shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\n    }\n    if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\n      shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\n    }\n  }\n  return new Line({\n    shape: shape,\n    style: style,\n    silent: true,\n    z2: z2\n  });\n}\nexport default MatrixView;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}