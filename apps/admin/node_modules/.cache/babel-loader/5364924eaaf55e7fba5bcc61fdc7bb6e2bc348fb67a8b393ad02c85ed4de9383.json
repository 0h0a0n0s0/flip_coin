{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { createHashMap, each, extend, isArray, isObject } from 'zrender/lib/core/util.js';\nimport { error } from '../../util/log.js';\nimport Point from 'zrender/lib/core/Point.js';\nimport { resolveXYLocatorRangeByCellMerge, MatrixClampOption, parseCoordRangeOption, fillIdSpanFromLocatorRange, createNaNRectLike, isXYLocatorRangeInvalidOnDim, resetXYLocatorRange, cloneXYLocatorRange } from './matrixCoordHelper.js';\n/**\n * Lifetime: the same with `MatrixModel`, but different from `coord/Matrix`.\n */\nvar MatrixBodyCorner = /** @class */function () {\n  function MatrixBodyCorner(kind, bodyOrCornerModel, dims) {\n    this._model = bodyOrCornerModel;\n    this._dims = dims;\n    this._kind = kind;\n    this._cellMergeOwnerList = [];\n  }\n  /**\n   * Can not be called before series models initialization finished, since the ordinalMeta may\n   * use collect the values from `series.data` in series initialization.\n   */\n  MatrixBodyCorner.prototype._ensureCellMap = function () {\n    var self = this;\n    var _cellMap = self._cellMap;\n    if (!_cellMap) {\n      _cellMap = self._cellMap = createHashMap();\n      fillCellMap();\n    }\n    return _cellMap;\n    function fillCellMap() {\n      var parsedList = [];\n      var cellOptionList = self._model.getShallow('data');\n      if (cellOptionList && !isArray(cellOptionList)) {\n        if (process.env.NODE_ENV !== 'production') {\n          error(\"matrix.\" + cellOptionList + \".data must be an array if specified.\");\n        }\n        cellOptionList = null;\n      }\n      each(cellOptionList, function (option, idx) {\n        if (!isObject(option) || !isArray(option.coord)) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Illegal matrix.\" + self._kind + \".data[\" + idx + \"], must be a {coord: [...], ...}\");\n          }\n          return;\n        }\n        var locatorRange = resetXYLocatorRange([]);\n        var reasonArr = null;\n        if (process.env.NODE_ENV !== 'production') {\n          reasonArr = [];\n        }\n        parseCoordRangeOption(locatorRange, reasonArr, option.coord, self._dims, option.coordClamp ? MatrixClampOption[self._kind] : MatrixClampOption.none);\n        if (isXYLocatorRangeInvalidOnDim(locatorRange, 0) || isXYLocatorRangeInvalidOnDim(locatorRange, 1)) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Can not determine cells by option matrix.\" + self._kind + \".data[\" + idx + \"]: \" + (\"\" + reasonArr.join(' ')));\n          }\n          return;\n        }\n        var cellMergeOwner = option && option.mergeCells;\n        var parsed = {\n          id: new Point(),\n          span: new Point(),\n          locatorRange: locatorRange,\n          option: option,\n          cellMergeOwner: cellMergeOwner\n        };\n        fillIdSpanFromLocatorRange(parsed, locatorRange);\n        // The order of the `parsedList` determines the precedence of the styles, if there\n        // are overlaps between ranges specified in different items. Preserve the original\n        // order of `matrix.body/corner/data` to make it predictable for users.\n        parsedList.push(parsed);\n      });\n      // Resolve cell merging intersection - union to a larger rect.\n      var mergedMarkList = [];\n      for (var parsedIdx = 0; parsedIdx < parsedList.length; parsedIdx++) {\n        var parsed = parsedList[parsedIdx];\n        if (!parsed.cellMergeOwner) {\n          continue;\n        }\n        var locatorRange = parsed.locatorRange;\n        resolveXYLocatorRangeByCellMerge(locatorRange, mergedMarkList, parsedList, parsedIdx);\n        for (var idx = 0; idx < parsedIdx; idx++) {\n          if (mergedMarkList[idx]) {\n            parsedList[idx].cellMergeOwner = false;\n          }\n        }\n        if (locatorRange[0][0] !== parsed.id.x || locatorRange[1][0] !== parsed.id.y) {\n          // The top-left cell of the unioned locatorRange is not this cell any more.\n          parsed.cellMergeOwner = false;\n          // Reconcile: simply use the last style and value option if multiple styles involved\n          // in a merged area, since there might be no commonly used merge strategy.\n          var newOption = extend({}, parsed.option);\n          newOption.coord = null;\n          var newParsed = {\n            id: new Point(),\n            span: new Point(),\n            locatorRange: locatorRange,\n            option: newOption,\n            cellMergeOwner: true\n          };\n          fillIdSpanFromLocatorRange(newParsed, locatorRange);\n          parsedList.push(newParsed);\n        }\n      }\n      // Assign options to cells.\n      each(parsedList, function (parsed) {\n        var topLeftCell = ensureBodyOrCornerCell(parsed.id.x, parsed.id.y);\n        if (parsed.cellMergeOwner) {\n          topLeftCell.cellMergeOwner = true;\n          topLeftCell.span = parsed.span;\n          topLeftCell.locatorRange = parsed.locatorRange;\n          topLeftCell.spanRect = createNaNRectLike();\n          self._cellMergeOwnerList.push(topLeftCell);\n        }\n        if (!parsed.cellMergeOwner && !parsed.option) {\n          return;\n        }\n        for (var yidx = 0; yidx < parsed.span.y; yidx++) {\n          for (var xidx = 0; xidx < parsed.span.x; xidx++) {\n            var cell = ensureBodyOrCornerCell(parsed.id.x + xidx, parsed.id.y + yidx);\n            // If multiple style options are defined on a cell, the later ones takes precedence.\n            cell.option = parsed.option;\n            if (parsed.cellMergeOwner) {\n              cell.inSpanOf = topLeftCell;\n            }\n          }\n        }\n      });\n    } // End of fillCellMap\n    function ensureBodyOrCornerCell(x, y) {\n      var key = makeCellMapKey(x, y);\n      var cell = _cellMap.get(key);\n      if (!cell) {\n        cell = _cellMap.set(key, {\n          id: new Point(x, y),\n          option: null,\n          inSpanOf: null,\n          span: null,\n          spanRect: null,\n          locatorRange: null,\n          cellMergeOwner: false\n        });\n      }\n      return cell;\n    }\n  };\n  /**\n   * Body cells or corner cell are not commonly defined specifically, especially in a large\n   * table, thus his is a sparse data structure - bodys or corner cells exist only if there\n   * are options specified to it (in `matrix.body.data` or `matrix.corner.data`);\n   * otherwise, return `NullUndefined`.\n   */\n  MatrixBodyCorner.prototype.getCell = function (xy) {\n    // Assert xy do not contain NaN\n    return this._ensureCellMap().get(makeCellMapKey(xy[0], xy[1]));\n  };\n  /**\n   * Only cell existing (has specific definition or props) will be travelled.\n   */\n  MatrixBodyCorner.prototype.travelExistingCells = function (cb) {\n    this._ensureCellMap().each(cb);\n  };\n  /**\n   * @param locatorRange Must be the return of `parseCoordRangeOption`.\n   */\n  MatrixBodyCorner.prototype.expandRangeByCellMerge = function (locatorRange) {\n    if (!isXYLocatorRangeInvalidOnDim(locatorRange, 0) && !isXYLocatorRangeInvalidOnDim(locatorRange, 1) && locatorRange[0][0] === locatorRange[0][1] && locatorRange[1][0] === locatorRange[1][1]) {\n      // If it locates to a single cell, use this quick path to avoid travelling.\n      // It is based on the fact that any cell is not contained by more than one cell merging rect.\n      _tmpERBCMLocator[0] = locatorRange[0][0];\n      _tmpERBCMLocator[1] = locatorRange[1][0];\n      var cell = this.getCell(_tmpERBCMLocator);\n      var inSpanOf = cell && cell.inSpanOf;\n      if (inSpanOf) {\n        cloneXYLocatorRange(locatorRange, inSpanOf.locatorRange);\n        return;\n      }\n    }\n    var list = this._cellMergeOwnerList;\n    resolveXYLocatorRangeByCellMerge(locatorRange, null, list, list.length);\n  };\n  return MatrixBodyCorner;\n}();\nexport { MatrixBodyCorner };\nvar _tmpERBCMLocator = [];\nfunction makeCellMapKey(x, y) {\n  return x + \"|\" + y;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}