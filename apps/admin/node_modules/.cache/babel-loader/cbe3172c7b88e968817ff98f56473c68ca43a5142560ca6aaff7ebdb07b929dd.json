{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { makeInner } from '../../util/model.js';\nimport { assert, each, extend, find, map } from 'zrender/lib/core/util.js';\nimport { getScaleBreakHelper } from '../../scale/break.js';\nimport { subPixelOptimizeLine } from 'zrender/lib/graphic/helper/subPixelOptimize.js';\nimport { applyTransform } from 'zrender/lib/core/vector.js';\nimport * as matrixUtil from 'zrender/lib/core/matrix.js';\nimport { AXIS_BREAK_COLLAPSE_ACTION_TYPE, AXIS_BREAK_EXPAND_ACTION_TYPE, AXIS_BREAK_TOGGLE_ACTION_TYPE } from './axisAction.js';\nimport { labelIntersect, labelLayoutApplyTranslation } from '../../label/labelLayoutHelper.js';\nimport { registerAxisBreakHelperImpl } from './axisBreakHelper.js';\nimport { warn } from '../../util/log.js';\nimport { Group, Line, Point, Polygon, Polyline, WH, XY } from '../../util/graphic.js';\n/**\n * @caution\n *  Must not export anything except `installAxisBreakHelper`\n */\n/**\n * The zigzag shapes for axis breaks are generated according to some random\n * factors. It should persist as much as possible to avoid constantly\n * changing by every user operation.\n */\nvar viewCache = makeInner();\nfunction ensureVisualInCache(visualList, targetBreak) {\n  var visual = find(visualList, function (item) {\n    return getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption);\n  });\n  if (!visual) {\n    visualList.push(visual = {\n      zigzagRandomList: [],\n      parsedBreak: targetBreak,\n      shouldRemove: false\n    });\n  }\n  return visual;\n}\nfunction resetCacheVisualRemoveFlag(visualList) {\n  each(visualList, function (item) {\n    return item.shouldRemove = true;\n  });\n}\nfunction removeUnusedCacheVisual(visualList) {\n  for (var i = visualList.length - 1; i >= 0; i--) {\n    if (visualList[i].shouldRemove) {\n      visualList.splice(i, 1);\n    }\n  }\n}\nfunction rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api) {\n  var axis = axisModel.axis;\n  if (axis.scale.isBlank() || !getScaleBreakHelper()) {\n    return;\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  if (!breakPairs.length) {\n    return;\n  }\n  var breakAreaModel = axisModel.getModel('breakArea');\n  var zigzagAmplitude = breakAreaModel.get('zigzagAmplitude');\n  var zigzagMinSpan = breakAreaModel.get('zigzagMinSpan');\n  var zigzagMaxSpan = breakAreaModel.get('zigzagMaxSpan');\n  // Use arbitrary value to avoid dead loop if user gives inappropriate settings.\n  zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);\n  zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);\n  var expandOnClick = breakAreaModel.get('expandOnClick');\n  var zigzagZ = breakAreaModel.get('zigzagZ');\n  var itemStyleModel = breakAreaModel.getModel('itemStyle');\n  var itemStyle = itemStyleModel.getItemStyle();\n  var borderColor = itemStyle.stroke;\n  var borderWidth = itemStyle.lineWidth;\n  var borderType = itemStyle.lineDash;\n  var color = itemStyle.fill;\n  var group = new Group({\n    ignoreModelZ: true\n  });\n  var isAxisHorizontal = axis.isHorizontal();\n  var cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);\n  resetCacheVisualRemoveFlag(cachedVisualList);\n  var _loop_1 = function (i) {\n    var parsedBreak = breakPairs[i][0][\"break\"].parsedBreak;\n    // Even if brk.gap is 0, we should also draw the breakArea because\n    // border is sometimes required to be visible (as a line)\n    var coords = [];\n    coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));\n    coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));\n    if (coords[1] < coords[0]) {\n      coords.reverse();\n    }\n    var cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);\n    cachedVisual.shouldRemove = false;\n    var breakGroup = new Group();\n    addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);\n    if (expandOnClick) {\n      breakGroup.on('click', function () {\n        var payload = {\n          type: AXIS_BREAK_EXPAND_ACTION_TYPE,\n          breaks: [{\n            start: parsedBreak.breakOption.start,\n            end: parsedBreak.breakOption.end\n          }]\n        };\n        payload[axis.dim + \"AxisIndex\"] = axisModel.componentIndex;\n        api.dispatchAction(payload);\n      });\n    }\n    breakGroup.silent = !expandOnClick;\n    group.add(breakGroup);\n  };\n  for (var i = 0; i < breakPairs.length; i++) {\n    _loop_1(i);\n  }\n  axisGroup.add(group);\n  removeUnusedCacheVisual(cachedVisualList);\n  function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal, trimmedBreak) {\n    var polylineStyle = {\n      stroke: borderColor,\n      lineWidth: borderWidth,\n      lineDash: borderType,\n      fill: 'none'\n    };\n    var dimBrk = isAxisHorizontal ? 0 : 1;\n    var dimZigzag = 1 - dimBrk;\n    var zigzagCoordMax = coordSysRect[XY[dimZigzag]] + coordSysRect[WH[dimZigzag]];\n    // Apply `subPixelOptimizeLine` for alignning with break ticks.\n    function subPixelOpt(brkCoord) {\n      var pBrk = [];\n      var dummyP = [];\n      pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;\n      pBrk[dimZigzag] = coordSysRect[XY[dimZigzag]];\n      dummyP[dimZigzag] = zigzagCoordMax;\n      var dummyShape = {\n        x1: pBrk[0],\n        y1: pBrk[1],\n        x2: dummyP[0],\n        y2: dummyP[1]\n      };\n      subPixelOptimizeLine(dummyShape, dummyShape, {\n        lineWidth: 1\n      });\n      pBrk[0] = dummyShape.x1;\n      pBrk[1] = dummyShape.y1;\n      return pBrk[dimBrk];\n    }\n    startCoord = subPixelOpt(startCoord);\n    endCoord = subPixelOpt(endCoord);\n    var pointsA = [];\n    var pointsB = [];\n    var isSwap = true;\n    var current = coordSysRect[XY[dimZigzag]];\n    for (var idx = 0;; idx++) {\n      // Use `isFirstPoint` `isLastPoint` to ensure the intersections between zigzag\n      // and axis are precise, thus it can join its axis tick correctly.\n      var isFirstPoint = current === coordSysRect[XY[dimZigzag]];\n      var isLastPoint = current >= zigzagCoordMax;\n      if (isLastPoint) {\n        current = zigzagCoordMax;\n      }\n      var pA = [];\n      var pB = [];\n      pA[dimBrk] = startCoord;\n      pB[dimBrk] = endCoord;\n      if (!isFirstPoint && !isLastPoint) {\n        pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;\n        pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;\n      }\n      pA[dimZigzag] = current;\n      pB[dimZigzag] = current;\n      pointsA.push(pA);\n      pointsB.push(pB);\n      var randomVal = void 0;\n      if (idx < zigzagRandomList.length) {\n        randomVal = zigzagRandomList[idx];\n      } else {\n        randomVal = Math.random();\n        zigzagRandomList.push(randomVal);\n      }\n      current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;\n      isSwap = !isSwap;\n      if (isLastPoint) {\n        break;\n      }\n    }\n    var anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);\n    // Create two polylines and add them to the breakGroup\n    breakGroup.add(new Polyline({\n      anid: \"break_a_\" + anidSuffix,\n      shape: {\n        points: pointsA\n      },\n      style: polylineStyle,\n      z: zigzagZ\n    }));\n    /* Add the second polyline and a polygon only if the gap is not zero\n     * Otherwise if the polyline is with dashed line or being opaque,\n     * it may not be constant with breaks with non-zero gaps. */\n    if (trimmedBreak.gapReal !== 0) {\n      breakGroup.add(new Polyline({\n        anid: \"break_b_\" + anidSuffix,\n        shape: {\n          // Not reverse to keep the dash stable when dragging resizing.\n          points: pointsB\n        },\n        style: polylineStyle,\n        z: zigzagZ\n      }));\n      // Creating the polygon that fills the area between the polylines\n      // From end to start for polygon.\n      var pointsB2 = pointsB.slice();\n      pointsB2.reverse();\n      var polygonPoints = pointsA.concat(pointsB2);\n      breakGroup.add(new Polygon({\n        anid: \"break_c_\" + anidSuffix,\n        shape: {\n          points: polygonPoints\n        },\n        style: {\n          fill: color,\n          opacity: itemStyle.opacity\n        },\n        z: zigzagZ\n      }));\n    }\n  }\n}\nfunction buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {\n  var axis = axisModel.axis;\n  var transform = transformGroup.transform;\n  assert(pathBaseProp.style);\n  var extent = axis.getExtent();\n  if (axis.inverse) {\n    extent = extent.slice();\n    extent.reverse();\n  }\n  var breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({\n    breakTicks: 'only_break'\n  }), function (tick) {\n    return tick[\"break\"];\n  }, false);\n  var brkLayoutList = map(breakPairs, function (breakPair) {\n    var parsedBreak = breakPair[0][\"break\"].parsedBreak;\n    var coordPair = [axis.dataToCoord(parsedBreak.vmin, true), axis.dataToCoord(parsedBreak.vmax, true)];\n    coordPair[0] > coordPair[1] && coordPair.reverse();\n    return {\n      coordPair: coordPair,\n      brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)\n    };\n  });\n  brkLayoutList.sort(function (layout1, layout2) {\n    return layout1.coordPair[0] - layout2.coordPair[0];\n  });\n  var ySegMin = extent[0];\n  var lastLayout = null;\n  for (var idx = 0; idx < brkLayoutList.length; idx++) {\n    var layout = brkLayoutList[idx];\n    var brkTirmmedMin = Math.max(layout.coordPair[0], extent[0]);\n    var brkTirmmedMax = Math.min(layout.coordPair[1], extent[1]);\n    if (ySegMin <= brkTirmmedMin) {\n      addSeg(ySegMin, brkTirmmedMin, lastLayout, layout);\n    }\n    ySegMin = brkTirmmedMax;\n    lastLayout = layout;\n  }\n  if (ySegMin <= extent[1]) {\n    addSeg(ySegMin, extent[1], lastLayout, null);\n  }\n  function addSeg(min, max, layout1, layout2) {\n    function trans(p1, p2) {\n      if (transform) {\n        applyTransform(p1, p1, transform);\n        applyTransform(p2, p2, transform);\n      }\n    }\n    function subPixelOptimizePP(p1, p2) {\n      var shape = {\n        x1: p1[0],\n        y1: p1[1],\n        x2: p2[0],\n        y2: p2[1]\n      };\n      subPixelOptimizeLine(shape, shape, pathBaseProp.style);\n      p1[0] = shape.x1;\n      p1[1] = shape.y1;\n      p2[0] = shape.x2;\n      p2[1] = shape.y2;\n    }\n    var lineP1 = [min, 0];\n    var lineP2 = [max, 0];\n    // dummy tick is used to align the line segment ends with axis ticks\n    // after `subPixelOptimizeLine` being applied.\n    var dummyTickEnd1 = [min, 5];\n    var dummyTickEnd2 = [max, 5];\n    trans(lineP1, dummyTickEnd1);\n    subPixelOptimizePP(lineP1, dummyTickEnd1);\n    trans(lineP2, dummyTickEnd2);\n    subPixelOptimizePP(lineP2, dummyTickEnd2);\n    // Apply it keeping the same as the normal axis line.\n    subPixelOptimizePP(lineP1, lineP2);\n    var seg = new Line(extend({\n      shape: {\n        x1: lineP1[0],\n        y1: lineP1[1],\n        x2: lineP2[0],\n        y2: lineP2[1]\n      }\n    }, pathBaseProp));\n    group.add(seg);\n    // Animation should be precise to be consistent with tick and split line animation.\n    seg.anid = \"breakLine_\" + (layout1 ? layout1.brkId : '\\0') + \"_\\0_\" + (layout2 ? layout2.brkId : '\\0');\n  }\n}\n/**\n * Resolve the overlap of a pair of labels.\n *\n * [CAUTION] Only label.x/y are allowed to change.\n */\nfunction adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {\n  if (find(layoutPair, function (item) {\n    return !item;\n  })) {\n    return;\n  }\n  var mtv = new Point();\n  if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {\n    // Assert `labelPair` is `[break_min, break_max]`.\n    // `axis.inverse: true` means a smaller scale value corresponds to a bigger value in axis.extent.\n    // The axisRotation indicates mtv direction of OBB intersecting.\n    direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),\n    touchThreshold: 0,\n    // If need to resovle intersection align axis by moving labels according to MTV,\n    // the direction must not be opposite, otherwise cause misleading.\n    bidirectional: false\n  })) {\n    return;\n  }\n  // Rotate axis back to (1, 0) direction, to be a standard axis.\n  var axisStTrans = matrixUtil.create();\n  matrixUtil.rotate(axisStTrans, axisStTrans, -axisRotation);\n  var labelPairStTrans = map(layoutPair, function (layout) {\n    return layout.transform ? matrixUtil.mul(matrixUtil.create(), axisStTrans, layout.transform) : axisStTrans;\n  });\n  function isParallelToAxis(whIdx) {\n    // Assert label[0] and label[1] has the same rotation, so only use [0].\n    var localRect = layoutPair[0].localRect;\n    var labelVec0 = new Point(localRect[WH[whIdx]] * labelPairStTrans[0][0], localRect[WH[whIdx]] * labelPairStTrans[0][1]);\n    return Math.abs(labelVec0.y) < 1e-5;\n  }\n  // If overlapping, move pair[0] pair[1] apart a little. We need to calculate a ratio k to\n  // distribute mtv to pair[0] and pair[1]. This is to place the text gap as close as possible\n  // to the center of the break ticks, otherwise it might looks weird or misleading.\n  // - When labels' width/height are not parallel to axis (usually by rotation),\n  //  we can simply treat the k as `0.5`.\n  var k = 0.5;\n  // - When labels' width/height are parallel to axis, the width/height need to be considered,\n  //  since they may differ significantly. In this case we keep textAlign as 'center' rather\n  //  than 'left'/'right', due to considerations of space utilization for wide break.gap.\n  //  A sample case: break on xAxis(no inverse) is [200, 300000].\n  //  We calculate k based on the formula below:\n  //      Rotated axis and labels to the direction of (1, 0).\n  //      uval = ( (pair[0].insidePt - mtv*k) + (pair[1].insidePt + mtv*(1-k)) ) / 2 - brkCenter\n  //      0 <= k <= 1\n  //      |uval| should be as small as possible.\n  //  Derived as follows:\n  //      qval = (pair[0].insidePt + pair[1].insidePt + mtv) / 2 - brkCenter\n  //      k = (qval - uval) / mtv\n  //      min(qval, qval-mtv) <= uval <= max(qval, qval-mtv)\n  if (isParallelToAxis(0) || isParallelToAxis(1)) {\n    var rectSt = map(layoutPair, function (layout, idx) {\n      var rect = layout.localRect.clone();\n      rect.applyTransform(labelPairStTrans[idx]);\n      return rect;\n    });\n    var brkCenterSt = new Point();\n    brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(0.5);\n    brkCenterSt.transform(axisStTrans);\n    var mtvSt = mtv.clone().transform(axisStTrans);\n    var insidePtSum = rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width);\n    var qval = (insidePtSum + mtvSt.x) / 2 - brkCenterSt.x;\n    var uvalMin = Math.min(qval, qval - mtvSt.x);\n    var uvalMax = Math.max(qval, qval - mtvSt.x);\n    var uval = uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0;\n    k = (qval - uval) / mtvSt.x;\n  }\n  var delta0 = new Point();\n  var delta1 = new Point();\n  Point.scale(delta0, mtv, -k);\n  Point.scale(delta1, mtv, 1 - k);\n  labelLayoutApplyTranslation(layoutPair[0], delta0);\n  labelLayoutApplyTranslation(layoutPair[1], delta1);\n}\nfunction updateModelAxisBreak(model, payload) {\n  var result = {\n    breaks: []\n  };\n  each(payload.breaks, function (inputBrk) {\n    if (!inputBrk) {\n      return;\n    }\n    var breakOption = find(model.get('breaks', true), function (brkOption) {\n      return getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk);\n    });\n    if (!breakOption) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn(\"Can not find axis break by start: \" + inputBrk.start + \", end: \" + inputBrk.end);\n      }\n      return;\n    }\n    var actionType = payload.type;\n    var old = {\n      isExpanded: !!breakOption.isExpanded\n    };\n    breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;\n    result.breaks.push({\n      start: breakOption.start,\n      end: breakOption.end,\n      isExpanded: !!breakOption.isExpanded,\n      old: old\n    });\n  });\n  return result;\n}\nexport function installAxisBreakHelper() {\n  registerAxisBreakHelperImpl({\n    adjustBreakLabelPair: adjustBreakLabelPair,\n    buildAxisBreakLine: buildAxisBreakLine,\n    rectCoordBuildBreakAxis: rectCoordBuildBreakAxis,\n    updateModelAxisBreak: updateModelAxisBreak\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}