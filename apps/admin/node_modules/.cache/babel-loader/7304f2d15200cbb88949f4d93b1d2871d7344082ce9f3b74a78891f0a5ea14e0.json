{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { assert, clone, each, find, isString, map, trim } from 'zrender/lib/core/util.js';\nimport { error } from '../util/log.js';\nimport { registerScaleBreakHelperImpl } from './break.js';\nimport { round as fixRound } from '../util/number.js';\n/**\n * @caution\n *  Must not export anything except `installScaleBreakHelper`\n */\nvar ScaleBreakContextImpl = /** @class */function () {\n  function ScaleBreakContextImpl() {\n    // [CAVEAT]: Should set only by `ScaleBreakContext#setBreaks`!\n    this.breaks = [];\n    // [CAVEAT]: Should update only by `ScaleBreakContext#update`!\n    // They are the values that scaleExtent[0] and scaleExtent[1] are mapped to a numeric axis\n    // that breaks are applied, primarily for optimization of `Scale#normalize`.\n    this._elapsedExtent = [Infinity, -Infinity];\n  }\n  ScaleBreakContextImpl.prototype.setBreaks = function (parsed) {\n    // @ts-ignore\n    this.breaks = parsed.breaks;\n  };\n  /**\n   * [CAVEAT]: Must be called immediately each time scale extent and breaks are updated!\n   */\n  ScaleBreakContextImpl.prototype.update = function (scaleExtent) {\n    updateAxisBreakGapReal(this, scaleExtent);\n    var elapsedExtent = this._elapsedExtent;\n    elapsedExtent[0] = this.elapse(scaleExtent[0]);\n    elapsedExtent[1] = this.elapse(scaleExtent[1]);\n  };\n  ScaleBreakContextImpl.prototype.hasBreaks = function () {\n    return !!this.breaks.length;\n  };\n  /**\n   * When iteratively generating ticks by nice interval, currently the `interval`, which is\n   * calculated by break-elapsed extent span, is probably very small comparing to the original\n   * extent, leading to a large number of iteration and tick generation, even over `safeLimit`.\n   * Thus stepping over breaks is necessary in that loop.\n   *\n   * \"Nice\" should be ensured on ticks when step over the breaks. Thus this method returns\n   * a integer multiple of the \"nice tick interval\".\n   *\n   * This method does little work; it is just for unifying and restricting the behavior.\n   */\n  ScaleBreakContextImpl.prototype.calcNiceTickMultiple = function (tickVal, estimateNiceMultiple) {\n    for (var idx = 0; idx < this.breaks.length; idx++) {\n      var brk = this.breaks[idx];\n      if (brk.vmin < tickVal && tickVal < brk.vmax) {\n        var multiple = estimateNiceMultiple(tickVal, brk.vmax);\n        if (process.env.NODE_ENV !== 'production') {\n          // If not, it may cause dead loop or not nice tick.\n          assert(multiple >= 0 && Math.round(multiple) === multiple);\n        }\n        return multiple;\n      }\n    }\n    return 0;\n  };\n  ScaleBreakContextImpl.prototype.getExtentSpan = function () {\n    return this._elapsedExtent[1] - this._elapsedExtent[0];\n  };\n  ScaleBreakContextImpl.prototype.normalize = function (val) {\n    var elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];\n    // The same logic as `Scale#normalize`.\n    if (elapsedSpan === 0) {\n      return 0.5;\n    }\n    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;\n  };\n  ScaleBreakContextImpl.prototype.scale = function (val) {\n    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);\n  };\n  /**\n   * Suppose:\n   *    AXIS_BREAK_LAST_BREAK_END_BASE: 0\n   *    AXIS_BREAK_ELAPSED_BASE: 0\n   *    breaks: [\n   *        {start: -400, end: -300, gap: 27},\n   *        {start: -100, end: 100, gap: 10},\n   *        {start: 200, end: 400, gap: 300},\n   *    ]\n   * The mapping will be:\n   *        |        |\n   *    400 +   ->   +  237\n   *     |  |        |   |  (gap: 300)\n   *    200 +   ->   + -63\n   *        |        |\n   *    100 +   ->   + -163\n   *     |  |        |   |  (gap: 10)\n   *   -100 +   ->   + -173\n   *        |        |\n   *   -300 +   ->   + -373\n   *     |  |        |   |  (gap: 27)\n   *   -400 +   ->   + -400\n   *        |        |\n   *   origianl     elapsed\n   *\n   * Note:\n   *   The mapping has nothing to do with \"scale extent\".\n   */\n  ScaleBreakContextImpl.prototype.elapse = function (val) {\n    // If the value is in the break, return the normalized value in the break\n    var elapsedVal = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      if (val <= brk.vmax) {\n        if (val > brk.vmin) {\n          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;\n        } else {\n          elapsedVal += val - lastBreakEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      elapsedVal += val - lastBreakEnd;\n    }\n    return elapsedVal;\n  };\n  ScaleBreakContextImpl.prototype.unelapse = function (elapsedVal) {\n    var lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;\n    var lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;\n    var stillOver = true;\n    var unelapsedVal = 0;\n    for (var i = 0; i < this.breaks.length; i++) {\n      var brk = this.breaks[i];\n      var elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;\n      var elapsedEnd = elapsedStart + brk.gapReal;\n      if (elapsedVal <= elapsedEnd) {\n        if (elapsedVal > elapsedStart) {\n          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);\n        } else {\n          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n        }\n        lastBreakEnd = brk.vmax;\n        stillOver = false;\n        break;\n      }\n      lastElapsedEnd = elapsedEnd;\n      lastBreakEnd = brk.vmax;\n    }\n    if (stillOver) {\n      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;\n    }\n    return unelapsedVal;\n  };\n  return ScaleBreakContextImpl;\n}();\n;\nfunction createScaleBreakContext() {\n  return new ScaleBreakContextImpl();\n}\n// Both can start with any finite value, and are not necessaryily equal. But they need to\n// be the same in `axisBreakElapse` and `axisBreakUnelapse` respectively.\nvar AXIS_BREAK_ELAPSED_BASE = 0;\nvar AXIS_BREAK_LAST_BREAK_END_BASE = 0;\n/**\n * `gapReal` in brkCtx.breaks will be calculated.\n */\nfunction updateAxisBreakGapReal(brkCtx, scaleExtent) {\n  // Considered the effect:\n  //  - Use dataZoom to move some of the breaks outside the extent.\n  //  - Some scenarios that `series.clip: false`.\n  //\n  // How to calculate `prctBrksGapRealSum`:\n  //  Based on the formula:\n  //      xxx.span = brk.vmax - brk.vmin\n  //      xxx.tpPrct.val / xxx.tpAbs.val means ParsedAxisBreak['gapParsed']['val']\n  //      .S/.E means a break that is semi in scaleExtent[0] or scaleExtent[1]\n  //      valP = (\n  //          + (fullyInExtBrksSum.tpAbs.gapReal - fullyInExtBrksSum.tpAbs.span)\n  //          + (semiInExtBrk.S.tpAbs.gapReal - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac\n  //          + (semiInExtBrk.E.tpAbs.gapReal - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac\n  //      )\n  //      valQ = (\n  //          - fullyInExtBrksSum.tpPrct.span\n  //          - semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac\n  //          - semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //      gapPrctSum = sum(xxx.tpPrct.val)\n  //      gapPrctSum = prctBrksGapRealSum / (\n  //          + (scaleExtent[1] - scaleExtent[0]) + valP + valQ\n  //          + fullyInExtBrksSum.tpPrct.gapReal\n  //          + semiInExtBrk.S.tpPrct.gapReal * semiInExtBrk.S.tpPrct.inExtFrac\n  //          + semiInExtBrk.E.tpPrct.gapReal * semiInExtBrk.E.tpPrct.inExtFrac\n  //      )\n  //  Assume:\n  //      xxx.tpPrct.gapReal = xxx.tpPrct.val / gapPrctSum * prctBrksGapRealSum\n  //         (NOTE: This is not accurate when semi-in-extent break exist because its\n  //         proportion is not linear, but this assumption approximately works.)\n  //  Derived as follows:\n  //      prctBrksGapRealSum = gapPrctSum * ( (scaleExtent[1] - scaleExtent[0]) + valP + valQ )\n  //          / (1\n  //              - fullyInExtBrksSum.tpPrct.val\n  //              - semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac\n  //              - semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac\n  //          )\n  var gapPrctSum = 0;\n  var fullyInExtBrksSum = {\n    tpAbs: {\n      span: 0,\n      val: 0\n    },\n    tpPrct: {\n      span: 0,\n      val: 0\n    }\n  };\n  var init = function () {\n    return {\n      has: false,\n      span: NaN,\n      inExtFrac: NaN,\n      val: NaN\n    };\n  };\n  var semiInExtBrk = {\n    S: {\n      tpAbs: init(),\n      tpPrct: init()\n    },\n    E: {\n      tpAbs: init(),\n      tpPrct: init()\n    }\n  };\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      gapPrctSum += gapParsed.val;\n    }\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (clampedBrk) {\n      var vminClamped = clampedBrk.vmin !== brk.vmin;\n      var vmaxClamped = clampedBrk.vmax !== brk.vmax;\n      var clampedSpan = clampedBrk.vmax - clampedBrk.vmin;\n      if (vminClamped && vmaxClamped) {\n        // Do nothing, which simply makes the result `gapReal` cover the entire scaleExtent.\n        // This transform is not consistent with the other cases but practically works.\n      } else if (vminClamped || vmaxClamped) {\n        var sOrE = vminClamped ? 'S' : 'E';\n        semiInExtBrk[sOrE][gapParsed.type].has = true;\n        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;\n        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);\n        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;\n      } else {\n        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;\n        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;\n      }\n    }\n  });\n  var prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));\n  each(brkCtx.breaks, function (brk) {\n    var gapParsed = brk.gapParsed;\n    if (gapParsed.type === 'tpPrct') {\n      brk.gapReal = gapPrctSum !== 0\n      // prctBrksGapRealSum is supposed to be non-negative but add a safe guard\n      ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;\n    }\n    if (gapParsed.type === 'tpAbs') {\n      brk.gapReal = gapParsed.val;\n    }\n    if (brk.gapReal == null) {\n      brk.gapReal = 0;\n    }\n  });\n}\nfunction pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {\n  if (pruneByBreak === 'no') {\n    return;\n  }\n  each(breaks, function (brk) {\n    // break.vmin/vmax that out of extent must not impact the visible of\n    // normal ticks and labels.\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // Remove some normal ticks to avoid zigzag shapes overlapping with split lines\n    // and to avoid break labels overlapping with normal tick labels (thouth it can\n    // also be avoided by `axisLabel.hideOverlap`).\n    // It's OK to O(n^2) since the number of `ticks` are small.\n    for (var j = ticks.length - 1; j >= 0; j--) {\n      var tick = ticks[j];\n      var val = getValue(tick);\n      // 1. Ensure there is no ticks inside `break.vmin` and `break.vmax`.\n      // 2. Use an empirically gap value here. Theoritically `zigzagAmplitude` is\n      //  supposed to be involved to provide better precision but it will brings\n      //  more complexity. The empirically gap value is conservative because break\n      //  labels and normal tick lables are prone to overlapping.\n      var gap = interval * 3 / 4;\n      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== 'preserve_extent_bound' || val !== scaleExtent[0] && val !== scaleExtent[1])) {\n        ticks.splice(j, 1);\n      }\n    }\n  });\n}\nfunction addBreaksToTicks(\n// The input ticks should be in accending order.\nticks, breaks, scaleExtent,\n// Keep the break ends at the same level to avoid an awkward appearance.\ngetTimeProps) {\n  each(breaks, function (brk) {\n    var clampedBrk = clampBreakByExtent(brk, scaleExtent);\n    if (!clampedBrk) {\n      return;\n    }\n    // - When neight `break.vmin` nor `break.vmax` is in scale extent,\n    //  break label should not be displayed and we do not add them to the result.\n    // - When only one of `break.vmin` and `break.vmax` is inside the extent and the\n    //  other is outsite, we comply with the extent and display only part of the breaks area,\n    //  because the extent might be determined by user settings (such as `axis.min/max`)\n    ticks.push({\n      value: clampedBrk.vmin,\n      \"break\": {\n        type: 'vmin',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n    // When gap is 0, start tick overlap with end tick, but we still count both of them. Break\n    // area shape can address that overlapping. `axisLabel` need draw both start and end separately,\n    // otherwise it brings complexity to the logic of label overlapping resolving (e.g., when label\n    // rotated), and introduces inconsistency to users in `axisLabel.formatter` between gap is 0 or not.\n    ticks.push({\n      value: clampedBrk.vmax,\n      \"break\": {\n        type: 'vmax',\n        parsedBreak: clampedBrk\n      },\n      time: getTimeProps ? getTimeProps(clampedBrk) : undefined\n    });\n  });\n  if (breaks.length) {\n    ticks.sort(function (a, b) {\n      return a.value - b.value;\n    });\n  }\n}\n/**\n * If break and extent does not intersect, return null/undefined.\n * If the intersection is only a point at scaleExtent[0] or scaleExtent[1], return null/undefined.\n */\nfunction clampBreakByExtent(brk, scaleExtent) {\n  var vmin = Math.max(brk.vmin, scaleExtent[0]);\n  var vmax = Math.min(brk.vmax, scaleExtent[1]);\n  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {\n    vmin: vmin,\n    vmax: vmax,\n    breakOption: brk.breakOption,\n    gapParsed: brk.gapParsed,\n    gapReal: brk.gapReal\n  } : null;\n}\nfunction parseAxisBreakOption(\n// raw user input breaks, retrieved from axis model.\nbreakOptionList, parse, opt) {\n  var parsedBreaks = [];\n  if (!breakOptionList) {\n    return {\n      breaks: parsedBreaks\n    };\n  }\n  function validatePercent(normalizedPercent, msg) {\n    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {\n      // Avoid division error.\n      return true;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      error(msg + \" must be >= 0 and < 1, rather than \" + normalizedPercent + \" .\");\n    }\n    return false;\n  }\n  each(breakOptionList, function (brkOption) {\n    if (!brkOption || brkOption.start == null || brkOption.end == null) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('The input axis breaks start/end should not be empty.');\n      }\n      return;\n    }\n    if (brkOption.isExpanded) {\n      return;\n    }\n    var parsedBrk = {\n      breakOption: clone(brkOption),\n      vmin: parse(brkOption.start),\n      vmax: parse(brkOption.end),\n      gapParsed: {\n        type: 'tpAbs',\n        val: 0\n      },\n      gapReal: null\n    };\n    if (brkOption.gap != null) {\n      var isPrct = false;\n      if (isString(brkOption.gap)) {\n        var trimmedGap = trim(brkOption.gap);\n        if (trimmedGap.match(/%$/)) {\n          var normalizedPercent = parseFloat(trimmedGap) / 100;\n          if (!validatePercent(normalizedPercent, 'Percent gap')) {\n            normalizedPercent = 0;\n          }\n          parsedBrk.gapParsed.type = 'tpPrct';\n          parsedBrk.gapParsed.val = normalizedPercent;\n          isPrct = true;\n        }\n      }\n      if (!isPrct) {\n        var absolute = parse(brkOption.gap);\n        if (!isFinite(absolute) || absolute < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis breaks gap must positive finite rather than (\" + brkOption.gap + \").\");\n          }\n          absolute = 0;\n        }\n        parsedBrk.gapParsed.type = 'tpAbs';\n        parsedBrk.gapParsed.val = absolute;\n      }\n    }\n    if (parsedBrk.vmin === parsedBrk.vmax) {\n      parsedBrk.gapParsed.type = 'tpAbs';\n      parsedBrk.gapParsed.val = 0;\n    }\n    if (opt && opt.noNegative) {\n      each(['vmin', 'vmax'], function (se) {\n        if (parsedBrk[se] < 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            error(\"Axis break.\" + se + \" must not be negative.\");\n          }\n          parsedBrk[se] = 0;\n        }\n      });\n    }\n    // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n    // User are allowed to input desending vmin/vmax for simplifying the usage.\n    if (parsedBrk.vmin > parsedBrk.vmax) {\n      var tmp = parsedBrk.vmax;\n      parsedBrk.vmax = parsedBrk.vmin;\n      parsedBrk.vmin = tmp;\n    }\n    parsedBreaks.push(parsedBrk);\n  });\n  // Ascending numerical order is the prerequisite of the calculation in Scale#normalize.\n  parsedBreaks.sort(function (item1, item2) {\n    return item1.vmin - item2.vmin;\n  });\n  // Make sure that the intervals in breaks are not overlap.\n  var lastEnd = -Infinity;\n  each(parsedBreaks, function (brk, idx) {\n    if (lastEnd > brk.vmin) {\n      if (process.env.NODE_ENV !== 'production') {\n        error('Axis breaks must not overlap.');\n      }\n      parsedBreaks[idx] = null;\n    }\n    lastEnd = brk.vmax;\n  });\n  return {\n    breaks: parsedBreaks.filter(function (brk) {\n      return !!brk;\n    })\n  };\n}\nfunction identifyAxisBreak(brk, identifier) {\n  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);\n}\nfunction serializeAxisBreakIdentifier(identifier) {\n  // We use user input start/end to identify break. Considered cases like `start: new Date(xxx)`,\n  // Theoretically `Scale#parse` should be used here, but not used currently to reduce dependencies,\n  // since simply converting to string happens to be correct.\n  return identifier.start + '_\\0_' + identifier.end;\n}\n/**\n * - A break pair represents `[vmin, vmax]`,\n * - Only both vmin and vmax item exist, they are counted as a pair.\n */\nfunction retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {\n  var idxPairList = [];\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmin') {\n      idxPairList.push([idx]);\n    }\n  });\n  each(itemList, function (el, idx) {\n    var vBreak = getVisualAxisBreak(el);\n    if (vBreak && vBreak.type === 'vmax') {\n      var idxPair = find(idxPairList,\n      // parsedBreak may be changed, can only use breakOption to match them.\n      function (pr) {\n        return identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption);\n      });\n      idxPair && idxPair.push(idx);\n    }\n  });\n  var result = [];\n  each(idxPairList, function (idxPair) {\n    if (idxPair.length === 2) {\n      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);\n    }\n  });\n  return result;\n}\nfunction getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError) {\n  var vBreak;\n  var brkRoundingCriterion;\n  if (tick[\"break\"]) {\n    var brk = tick[\"break\"].parsedBreak;\n    var originalBreak = find(logOriginalBreaks, function (brk) {\n      return identifyAxisBreak(brk.breakOption, tick[\"break\"].parsedBreak.breakOption);\n    });\n    var vmin = fixRoundingError(Math.pow(logBase, brk.vmin), originalBreak.vmin);\n    var vmax = fixRoundingError(Math.pow(logBase, brk.vmax), originalBreak.vmax);\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? fixRound(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val\n    };\n    vBreak = {\n      type: tick[\"break\"].type,\n      parsedBreak: {\n        breakOption: brk.breakOption,\n        vmin: vmin,\n        vmax: vmax,\n        gapParsed: gapParsed,\n        gapReal: brk.gapReal\n      }\n    };\n    brkRoundingCriterion = originalBreak[tick[\"break\"].type];\n  }\n  return {\n    brkRoundingCriterion: brkRoundingCriterion,\n    vBreak: vBreak\n  };\n}\nfunction logarithmicParseBreaksFromOption(breakOptionList, logBase, parse) {\n  var opt = {\n    noNegative: true\n  };\n  var parsedOriginal = parseAxisBreakOption(breakOptionList, parse, opt);\n  var parsedLogged = parseAxisBreakOption(breakOptionList, parse, opt);\n  var loggedBase = Math.log(logBase);\n  parsedLogged.breaks = map(parsedLogged.breaks, function (brk) {\n    var vmin = Math.log(brk.vmin) / loggedBase;\n    var vmax = Math.log(brk.vmax) / loggedBase;\n    var gapParsed = {\n      type: brk.gapParsed.type,\n      val: brk.gapParsed.type === 'tpAbs' ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val\n    };\n    return {\n      vmin: vmin,\n      vmax: vmax,\n      gapParsed: gapParsed,\n      gapReal: brk.gapReal,\n      breakOption: brk.breakOption\n    };\n  });\n  return {\n    parsedOriginal: parsedOriginal,\n    parsedLogged: parsedLogged\n  };\n}\nvar BREAK_MIN_MAX_TO_PARAM = {\n  vmin: 'start',\n  vmax: 'end'\n};\nfunction makeAxisLabelFormatterParamBreak(extraParam, vBreak) {\n  if (vBreak) {\n    extraParam = extraParam || {};\n    extraParam[\"break\"] = {\n      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],\n      start: vBreak.parsedBreak.vmin,\n      end: vBreak.parsedBreak.vmax\n    };\n  }\n  return extraParam;\n}\nexport function installScaleBreakHelper() {\n  registerScaleBreakHelperImpl({\n    createScaleBreakContext: createScaleBreakContext,\n    pruneTicksByBreak: pruneTicksByBreak,\n    addBreaksToTicks: addBreaksToTicks,\n    parseAxisBreakOption: parseAxisBreakOption,\n    identifyAxisBreak: identifyAxisBreak,\n    serializeAxisBreakIdentifier: serializeAxisBreakIdentifier,\n    retrieveAxisBreakPairs: retrieveAxisBreakPairs,\n    getTicksLogTransformBreak: getTicksLogTransformBreak,\n    logarithmicParseBreaksFromOption: logarithmicParseBreaksFromOption,\n    makeAxisLabelFormatterParamBreak: makeAxisLabelFormatterParamBreak\n  });\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}