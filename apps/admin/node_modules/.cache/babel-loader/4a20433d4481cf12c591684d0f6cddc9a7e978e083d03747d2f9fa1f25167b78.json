{"ast":null,"code":"import * as imageHelper from '../helper/image.js';\nimport { extend, retrieve2, retrieve3, reduce } from '../../core/util.js';\nimport { adjustTextX, adjustTextY, ensureFontMeasureInfo, getLineHeight, measureCharWidth, measureWidth, parsePercent } from '../../contain/text.js';\nimport BoundingRect from '../../core/BoundingRect.js';\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nexport function truncateText(text, containerWidth, font, ellipsis, options) {\n  var out = {};\n  truncateText2(out, text, containerWidth, font, ellipsis, options);\n  return out.text;\n}\nfunction truncateText2(out, text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    out.text = '';\n    out.isTruncated = false;\n    return;\n  }\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n  var isTruncated = false;\n  var truncateOut = {};\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    truncateSingleLine(truncateOut, textLines[i], options);\n    textLines[i] = truncateOut.textLine;\n    isTruncated = isTruncated || truncateOut.isTruncated;\n  }\n  out.text = textLines.join('\\n');\n  out.isTruncated = isTruncated;\n}\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = options || {};\n  var preparedOpts = extend({}, options);\n  ellipsis = retrieve2(ellipsis, '...');\n  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);\n  var fontMeasureInfo = preparedOpts.fontMeasureInfo = ensureFontMeasureInfo(font);\n  var ascCharWidth = fontMeasureInfo.asciiCharWidth;\n  preparedOpts.placeholder = retrieve2(options.placeholder, '');\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n  var ellipsisWidth = measureWidth(fontMeasureInfo, ellipsis);\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n  contentWidth = containerWidth - ellipsisWidth;\n  preparedOpts.ellipsis = ellipsis;\n  preparedOpts.ellipsisWidth = ellipsisWidth;\n  preparedOpts.contentWidth = contentWidth;\n  preparedOpts.containerWidth = containerWidth;\n  return preparedOpts;\n}\nfunction truncateSingleLine(out, textLine, options) {\n  var containerWidth = options.containerWidth;\n  var contentWidth = options.contentWidth;\n  var fontMeasureInfo = options.fontMeasureInfo;\n  if (!containerWidth) {\n    out.textLine = '';\n    out.isTruncated = false;\n    return;\n  }\n  var lineWidth = measureWidth(fontMeasureInfo, textLine);\n  if (lineWidth <= containerWidth) {\n    out.textLine = textLine;\n    out.isTruncated = false;\n    return;\n  }\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, fontMeasureInfo) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = measureWidth(fontMeasureInfo, textLine);\n  }\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n  out.textLine = textLine;\n  out.isTruncated = true;\n}\nfunction estimateLength(text, contentWidth, fontMeasureInfo) {\n  var width = 0;\n  var i = 0;\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    width += measureCharWidth(fontMeasureInfo, text.charCodeAt(i));\n  }\n  return i;\n}\nexport function parsePlainText(rawText, style, defaultOuterWidth, defaultOuterHeight) {\n  var text = formatText(rawText);\n  var overflow = style.overflow;\n  var padding = style.padding;\n  var paddingH = padding ? padding[1] + padding[3] : 0;\n  var paddingV = padding ? padding[0] + padding[2] : 0;\n  var font = style.font;\n  var truncate = overflow === 'truncate';\n  var calculatedLineHeight = getLineHeight(font);\n  var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);\n  var truncateLineOverflow = style.lineOverflow === 'truncate';\n  var isTruncated = false;\n  var width = style.width;\n  if (width == null && defaultOuterWidth != null) {\n    width = defaultOuterWidth - paddingH;\n  }\n  var height = style.height;\n  if (height == null && defaultOuterHeight != null) {\n    height = defaultOuterHeight - paddingV;\n  }\n  var lines;\n  if (width != null && (overflow === 'break' || overflow === 'breakAll')) {\n    lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n  } else {\n    lines = text ? text.split('\\n') : [];\n  }\n  var contentHeight = lines.length * lineHeight;\n  if (height == null) {\n    height = contentHeight;\n  }\n  if (contentHeight > height && truncateLineOverflow) {\n    var lineCount = Math.floor(height / lineHeight);\n    isTruncated = isTruncated || lines.length > lineCount;\n    lines = lines.slice(0, lineCount);\n    contentHeight = lines.length * lineHeight;\n  }\n  if (text && truncate && width != null) {\n    var options = prepareTruncateOptions(width, font, style.ellipsis, {\n      minChar: style.truncateMinChar,\n      placeholder: style.placeholder\n    });\n    var singleOut = {};\n    for (var i = 0; i < lines.length; i++) {\n      truncateSingleLine(singleOut, lines[i], options);\n      lines[i] = singleOut.textLine;\n      isTruncated = isTruncated || singleOut.isTruncated;\n    }\n  }\n  var outerHeight = height;\n  var contentWidth = 0;\n  var fontMeasureInfo = ensureFontMeasureInfo(font);\n  for (var i = 0; i < lines.length; i++) {\n    contentWidth = Math.max(measureWidth(fontMeasureInfo, lines[i]), contentWidth);\n  }\n  if (width == null) {\n    width = contentWidth;\n  }\n  var outerWidth = width;\n  outerHeight += paddingV;\n  outerWidth += paddingH;\n  return {\n    lines: lines,\n    height: height,\n    outerWidth: outerWidth,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    calculatedLineHeight: calculatedLineHeight,\n    contentWidth: contentWidth,\n    contentHeight: contentHeight,\n    width: width,\n    isTruncated: isTruncated\n  };\n}\nvar RichTextToken = function () {\n  function RichTextToken() {}\n  return RichTextToken;\n}();\nvar RichTextLine = function () {\n  function RichTextLine(tokens) {\n    this.tokens = [];\n    if (tokens) {\n      this.tokens = tokens;\n    }\n  }\n  return RichTextLine;\n}();\nvar RichTextContentBlock = function () {\n  function RichTextContentBlock() {\n    this.width = 0;\n    this.height = 0;\n    this.contentWidth = 0;\n    this.contentHeight = 0;\n    this.outerWidth = 0;\n    this.outerHeight = 0;\n    this.lines = [];\n    this.isTruncated = false;\n  }\n  return RichTextContentBlock;\n}();\nexport { RichTextContentBlock };\nexport function parseRichText(rawText, style, defaultOuterWidth, defaultOuterHeight, topTextAlign) {\n  var contentBlock = new RichTextContentBlock();\n  var text = formatText(rawText);\n  if (!text) {\n    return contentBlock;\n  }\n  var stlPadding = style.padding;\n  var stlPaddingH = stlPadding ? stlPadding[1] + stlPadding[3] : 0;\n  var stlPaddingV = stlPadding ? stlPadding[0] + stlPadding[2] : 0;\n  var topWidth = style.width;\n  if (topWidth == null && defaultOuterWidth != null) {\n    topWidth = defaultOuterWidth - stlPaddingH;\n  }\n  var topHeight = style.height;\n  if (topHeight == null && defaultOuterHeight != null) {\n    topHeight = defaultOuterHeight - stlPaddingV;\n  }\n  var overflow = style.overflow;\n  var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null ? {\n    width: topWidth,\n    accumWidth: 0,\n    breakAll: overflow === 'breakAll'\n  } : null;\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n    }\n    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n  }\n  var pendingList = [];\n  var calculatedHeight = 0;\n  var calculatedWidth = 0;\n  var truncate = overflow === 'truncate';\n  var truncateLine = style.lineOverflow === 'truncate';\n  var tmpTruncateOut = {};\n  function finishLine(line, lineWidth, lineHeight) {\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    calculatedHeight += lineHeight;\n    calculatedWidth = Math.max(calculatedWidth, lineWidth);\n  }\n  outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n      var textPadding = token.textPadding = tokenStyle.padding;\n      var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n      var font = token.font = tokenStyle.font || style.font;\n      token.contentHeight = getLineHeight(font);\n      var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);\n      token.innerHeight = tokenHeight;\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n      token.align = tokenStyle && tokenStyle.align || topTextAlign;\n      token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n      if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n        var originalLength = contentBlock.lines.length;\n        if (j > 0) {\n          line.tokens = line.tokens.slice(0, j);\n          finishLine(line, lineWidth, lineHeight);\n          contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n        } else {\n          contentBlock.lines = contentBlock.lines.slice(0, i);\n        }\n        contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;\n        break outer;\n      }\n      var styleTokenWidth = tokenStyle.width;\n      var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n      if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n        token.percentWidth = styleTokenWidth;\n        pendingList.push(token);\n        token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);\n      } else {\n        if (tokenWidthNotSpecified) {\n          var textBackgroundColor = tokenStyle.backgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image;\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n            if (imageHelper.isImageReady(bgImg)) {\n              token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n        var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;\n        if (remainTruncWidth != null && remainTruncWidth < token.width) {\n          if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n            token.text = '';\n            token.width = token.contentWidth = 0;\n          } else {\n            truncateText2(tmpTruncateOut, token.text, remainTruncWidth - paddingH, font, style.ellipsis, {\n              minChar: style.truncateMinChar\n            });\n            token.text = tmpTruncateOut.text;\n            contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;\n            token.width = token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);\n          }\n        } else {\n          token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);\n        }\n      }\n      token.width += paddingH;\n      lineWidth += token.width;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n    finishLine(line, lineWidth, lineHeight);\n  }\n  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);\n  contentBlock.contentHeight = calculatedHeight;\n  contentBlock.contentWidth = calculatedWidth;\n  contentBlock.outerWidth += stlPaddingH;\n  contentBlock.outerHeight += stlPaddingV;\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth;\n    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n  }\n  return contentBlock;\n}\nfunction pushTokens(block, str, style, wrapInfo, styleName) {\n  var isEmptyStr = str === '';\n  var tokenStyle = styleName && style.rich[styleName] || {};\n  var lines = block.lines;\n  var font = tokenStyle.font || style.font;\n  var newLine = false;\n  var strLines;\n  var linesWidths;\n  if (wrapInfo) {\n    var tokenPadding = tokenStyle.padding;\n    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n    if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n      var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n      if (lines.length > 0) {\n        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n          strLines = str.split('\\n');\n          newLine = true;\n        }\n      }\n      wrapInfo.accumWidth = outerWidth_1;\n    } else {\n      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n      linesWidths = res.linesWidths;\n      strLines = res.lines;\n    }\n  }\n  if (!strLines) {\n    strLines = str.split('\\n');\n  }\n  var fontMeasureInfo = ensureFontMeasureInfo(font);\n  for (var i = 0; i < strLines.length; i++) {\n    var text = strLines[i];\n    var token = new RichTextToken();\n    token.styleName = styleName;\n    token.text = text;\n    token.isLineHolder = !text && !isEmptyStr;\n    if (typeof tokenStyle.width === 'number') {\n      token.width = tokenStyle.width;\n    } else {\n      token.width = linesWidths ? linesWidths[i] : measureWidth(fontMeasureInfo, text);\n    }\n    if (!i && !newLine) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } else {\n      lines.push(new RichTextLine([token]));\n    }\n  }\n}\nfunction isAlphabeticLetter(ch) {\n  var code = ch.charCodeAt(0);\n  return code >= 0x20 && code <= 0x24F || code >= 0x370 && code <= 0x10FF || code >= 0x1200 && code <= 0x13FF || code >= 0x1E00 && code <= 0x206F;\n}\nvar breakCharMap = reduce(',&?/;] '.split(''), function (obj, ch) {\n  obj[ch] = true;\n  return obj;\n}, {});\nfunction isWordBreakChar(ch) {\n  if (isAlphabeticLetter(ch)) {\n    if (breakCharMap[ch]) {\n      return true;\n    }\n    return false;\n  }\n  return true;\n}\nfunction wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n  var lines = [];\n  var linesWidths = [];\n  var line = '';\n  var currentWord = '';\n  var currentWordWidth = 0;\n  var accumWidth = 0;\n  var fontMeasureInfo = ensureFontMeasureInfo(font);\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n    if (ch === '\\n') {\n      if (currentWord) {\n        line += currentWord;\n        accumWidth += currentWordWidth;\n      }\n      lines.push(line);\n      linesWidths.push(accumWidth);\n      line = '';\n      currentWord = '';\n      currentWordWidth = 0;\n      accumWidth = 0;\n      continue;\n    }\n    var chWidth = measureCharWidth(fontMeasureInfo, ch.charCodeAt(0));\n    var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {\n      if (!accumWidth) {\n        if (inWord) {\n          lines.push(currentWord);\n          linesWidths.push(currentWordWidth);\n          currentWord = ch;\n          currentWordWidth = chWidth;\n        } else {\n          lines.push(ch);\n          linesWidths.push(chWidth);\n        }\n      } else if (line || currentWord) {\n        if (inWord) {\n          if (!line) {\n            line = currentWord;\n            currentWord = '';\n            currentWordWidth = 0;\n            accumWidth = currentWordWidth;\n          }\n          lines.push(line);\n          linesWidths.push(accumWidth - currentWordWidth);\n          currentWord += ch;\n          currentWordWidth += chWidth;\n          line = '';\n          accumWidth = currentWordWidth;\n        } else {\n          if (currentWord) {\n            line += currentWord;\n            currentWord = '';\n            currentWordWidth = 0;\n          }\n          lines.push(line);\n          linesWidths.push(accumWidth);\n          line = ch;\n          accumWidth = chWidth;\n        }\n      }\n      continue;\n    }\n    accumWidth += chWidth;\n    if (inWord) {\n      currentWord += ch;\n      currentWordWidth += chWidth;\n    } else {\n      if (currentWord) {\n        line += currentWord;\n        currentWord = '';\n        currentWordWidth = 0;\n      }\n      line += ch;\n    }\n  }\n  if (currentWord) {\n    line += currentWord;\n  }\n  if (line) {\n    lines.push(line);\n    linesWidths.push(accumWidth);\n  }\n  if (lines.length === 1) {\n    accumWidth += lastAccumWidth;\n  }\n  return {\n    accumWidth: accumWidth,\n    lines: lines,\n    linesWidths: linesWidths\n  };\n}\nexport function calcInnerTextOverflowArea(out, overflowRect, baseX, baseY, textAlign, textVerticalAlign) {\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.outerWidth = out.outerHeight = null;\n  if (!overflowRect) {\n    return;\n  }\n  var textWidth = overflowRect.width * 2;\n  var textHeight = overflowRect.height * 2;\n  BoundingRect.set(tmpCITCTextRect, adjustTextX(baseX, textWidth, textAlign), adjustTextY(baseY, textHeight, textVerticalAlign), textWidth, textHeight);\n  BoundingRect.intersect(overflowRect, tmpCITCTextRect, null, tmpCITCIntersectRectOpt);\n  var outIntersectRect = tmpCITCIntersectRectOpt.outIntersectRect;\n  out.outerWidth = outIntersectRect.width;\n  out.outerHeight = outIntersectRect.height;\n  out.baseX = adjustTextX(outIntersectRect.x, outIntersectRect.width, textAlign, true);\n  out.baseY = adjustTextY(outIntersectRect.y, outIntersectRect.height, textVerticalAlign, true);\n}\nvar tmpCITCTextRect = new BoundingRect(0, 0, 0, 0);\nvar tmpCITCIntersectRectOpt = {\n  outIntersectRect: {},\n  clamp: true\n};\nfunction formatText(text) {\n  return text != null ? text += '' : text = '';\n}\nexport function tSpanCreateBoundingRect(style) {\n  var text = formatText(style.text);\n  var font = style.font;\n  var contentWidth = measureWidth(ensureFontMeasureInfo(font), text);\n  var contentHeight = getLineHeight(font);\n  return tSpanCreateBoundingRect2(style, contentWidth, contentHeight, null);\n}\nexport function tSpanCreateBoundingRect2(style, contentWidth, contentHeight, forceLineWidth) {\n  var rect = new BoundingRect(adjustTextX(style.x || 0, contentWidth, style.textAlign), adjustTextY(style.y || 0, contentHeight, style.textBaseline), contentWidth, contentHeight);\n  var lineWidth = forceLineWidth != null ? forceLineWidth : tSpanHasStroke(style) ? style.lineWidth : 0;\n  if (lineWidth > 0) {\n    rect.x -= lineWidth / 2;\n    rect.y -= lineWidth / 2;\n    rect.width += lineWidth;\n    rect.height += lineWidth;\n  }\n  return rect;\n}\nexport function tSpanHasStroke(style) {\n  var stroke = style.stroke;\n  return stroke != null && stroke !== 'none' && style.lineWidth > 0;\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}